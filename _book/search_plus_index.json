{"./":{"url":"./","title":"简介","keywords":"","body":"作者 q1，一年Flutter工作经验，企业内部Flutter培训讲师，Flutter开发组长， Flutter教程网 创办者，微信公众号\"Flutter前线\"小编， FlutterCandies开源组织成员，具有： wechat_flutter， nav_router等开源项目作品， 视频课程：Flutter实用例子进阶课程 ， 高仿谷歌翻译项目课程， 目前就职于广州某创业公司， 持续对Flutter社区输出文章资源，主要关注移动端行业发展和技术更新迭代，不断进步。 简介 本书主要讲解Flutter进阶，深入原理，以及工作所可能遇到的技术栈和问题解决方案、面试中 可能遇到的问题，以实战角度进行：文案、思维导图、代码示例、工作原理、使用方式进行讲解， 可帮助开发者快速进阶flutter技术。 章节介绍 本书分为多个章节，不确定性，会一直更，直到完善，然后固定章节，目前已有章节： 进阶篇、原理篇、Flutter面试题。 本书暂未想过发版实体书，主要发布电子版供大家学习参考。 持续更新中。。。敬请期待！ "},"chapter1/":{"url":"chapter1/","title":"第一章：进阶篇","keywords":"","body":"本章目录 Flutter的生命周期 局部刷新优化性能 屏幕适配之组件应用 屏幕适配之屏幕算法 根据控件位置弹出对话框 "},"chapter1/life_cycle.html":{"url":"chapter1/life_cycle.html","title":"1.1：生命周期","keywords":"","body":"生命周期 Flutter生命周期相对于android的Activity，ta存在于framework.dart的State类， 实测 写个有状态类并混入WidgetsBindingObserver配合监听特殊状态及其一个按钮，调用setState， 给生命周期的方法新增打印： import 'package:flutter/material.dart'; void main() => runApp(new MyApp()); class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return new MaterialApp( title: '生命周期', home: new LiftCycle(), ); } } class LiftCycle extends StatefulWidget { @override _LiftCycleState createState() => _LiftCycleState(); } class _LiftCycleState extends State with WidgetsBindingObserver { int count = 0; @override void initState() { super.initState(); WidgetsBinding.instance.addObserver(this); print('初始化 initState'); } @override void didUpdateWidget(LiftCycle oldWidget) { super.didUpdateWidget(oldWidget); print('组件更新 didUpdateWidget'); } @override void reassemble() { super.reassemble(); print('重新安装 reassemble'); } @override void deactivate() { super.deactivate(); print('停用 deactivate'); } @override void dispose() { super.dispose(); WidgetsBinding.instance.removeObserver(this); print('销毁 dispose'); } @override void didChangeAppLifecycleState(AppLifecycleState state) { super.didChangeAppLifecycleState(state); print('特殊状态 state：$state'); } @override void setState(fn) { super.setState(fn); print('状态刷新 setState'); } @override Widget build(BuildContext context) { return new Scaffold( appBar: new AppBar(title: new Text('生命周期')), body: new Center( child: new FlatButton( onPressed: () => setState(() => count++), child: new Text('$count'), ), ), ); } @override void didChangeDependencies() { super.didChangeDependencies(); print('依赖改变 didChangeDependencies'); } } 然后我们现在来看看打印流程，正常打开App什么都不操作，就打印了： I/flutter (15867): 初始化 initState I/flutter (15867): 依赖改变 didChangeDependencies I/flutter (15867): 重新安装 reassemble I/flutter (15867): 组件更新 didUpdateWidget 热重载打印： I/flutter (16141): 重新安装 reassemble I/flutter (16141): 组件更新 didUpdateWidget Reloaded 0 of 468 libraries in 186ms. 点击按钮打印： I/flutter (16141): 状态刷新 setState // count也+1了，说明重新调用过build。 流程图 图解主要部分： 1.构建（build）； 2.如果用户调用了setState时则状态刷新，重新build； 3.如果销毁先停用然后dispose销毁再结束； 构造函数 构造函数不属于生命周期，必然是要第一个调用的，也就是调用前State的widget属性为空。 initState 初始化 当此对象插入树中时调用，框架会调用一次此方法并不会再次重复执行， 如果[State]的[build]方法依赖于本身可以更改状态的对象，例如[ChangeNotifier]或[Stream]， 或者某些其他可以订阅的对象接收通知，可以在此方法订阅，但记得去dispose取消订阅； didChangeDependencies 依赖改变 顾名思义，依赖项更改时调用，但也会在initState之后调用， 在这个方法调用[BuildContext.inheritFromWidgetOfExactType]是安全的。 build 构建 会在以下场景调用： initState()之后； didUpdateWidget()之后； setState()之后。 didChangeDependencies()之后。 State对象从树中一个位置移除后会调用deactivate，然后又重新插入到树的其它位置之后。 reassemble 重新安装 专门为了开发调试而提供的，在热重载(hot reload)时会被调用，此回调在Release模式下永远不会被调用。 didUpdateWidget 组件更新 当组件的状态改变的时候就会调用didUpdateWidget(),比如调用了setState()， 在widget重新构建时，Flutter framework会调用Widget.canUpdate来检测Widget树中同一位置的新旧节点， 然后决定是否需要更新，如果Widget.canUpdate返回true则会调用此回调。正如之前所述，Widget.canUpdate会在 新旧widget的key和runtimeType同时相等时会返回true，也就是说在新旧widget的key和runtimeType同时相等时didUpdateWidget()就会被调用。 deactivate 暂停 State对象从树中被移除时（在dispose之前），会调用这个函数来将对象暂停。 dispose 销毁 当State对象被销毁时调用，通常在此回调中释放资源和移除监听。 【 特殊状态 】 我们自定义的State类混入了WidgetsBindingObserver，所以可以使用他的暂停和恢复， 初始化： @override void initState() { super.initState(); WidgetsBinding.instance.addObserver(this); // 在这初始化了 print('初始化 initState'); } 销毁： @override void dispose() { super.dispose(); WidgetsBinding.instance.removeObserver(this); // 在这销毁 print('销毁 dispose'); } 使用： @override void didChangeAppLifecycleState(AppLifecycleState state) { super.didChangeAppLifecycleState(state); print('特殊状态 state：$state'); } 这个didChangeAppLifecycleState是WidgetsBindingObserver类的一个方法， 可以用来判断当前的状态是在前台还是后台。 这个方法接收一个AppLifecycleState类型的枚举： 枚举值 含义 resumed 程序可见，并响应用户输入。 inactive 处于非活动状态，未收到用户输入。 paused 程序当前不可见，不响应用户输入，并且在后台运行。 suspending 程序将暂时暂停。 AppLifecycleState实测 当App返回到桌面或者其他不可见状态，但并未结束： I/flutter ( 2428): 特殊状态 state：AppLifecycleState.inactive I/flutter ( 2428): 特殊状态 state：AppLifecycleState.paused 当App回到可见状态： I/flutter ( 2428): 特殊状态 state：AppLifecycleState.inactive I/flutter ( 2428): 特殊状态 state：AppLifecycleState.resumed 流程图： "},"chapter1/partial_refresh.html":{"url":"chapter1/partial_refresh.html","title":"1.2：局部刷新优化性能","keywords":"","body":"局部刷新优化性能 Flutter状态类： StatelessWidget：无状态类，没有状态更新，界面一经创建无法更改； StatefulWidget：有状态类，当状态改变，调用setState()方法会触发StatefulWidget的UI状态更新，自定义继承StatefulWidget的子类须重写createState()方法。 案例： 当我们调用有状态类的setState方法时会遍历每一个子Widget的State.build刷新状态， 这将是一笔很大的性能开销，所以我们需要使用局部刷新来进行优化。 普通刷新方式 class TestRoute extends StatefulWidget { @override _TestRouteState createState() => _TestRouteState(); } class _TestRouteState extends State { int count = 0; @override Widget build(BuildContext context) { return new FlatButton( onPressed: () { setState(() => count++); }, child: new Text('$count'), ); } } 一个有状态类定义一个变量然后按钮的事件调用setState让这个变量进行刷新， 使用GlobalKey局部刷新方式 我们还是用上面的例子，只是通过GlobalKey的方式只刷新局部的Text， class TestRoute extends StatefulWidget { @override _TestRouteState createState() => _TestRouteState(); } class _TestRouteState extends State { int count = 0; GlobalKey textKey = GlobalKey(); @override Widget build(BuildContext context) { return new Column( mainAxisAlignment: MainAxisAlignment.center, children: [ new TextWidget(textKey), //需要更新的Text new FlatButton( onPressed: () { count++; // 这里我们只给他值变动，状态刷新交给下面的Key事件 textKey.currentState.onPressed(count); }, child: new Text('按钮 $count'), ), ], ); } } // 封装的文本组件Widget class TextWidget extends StatefulWidget { final Key key; // 接收一个Key TextWidget(this.key); @override State createState() => TextWidgetState(); } class TextWidgetState extends State { String _text = \"0\"; @override Widget build(BuildContext context) { return new Text(_text); } void onPressed(int count) { setState(() => _text = count.toString()); } } 效果： 可以明显的看到按钮的count并无变动，但需要更新的文本组件更新了值，已经完美实现了局部刷新。 实现原理： textKey是一个GlobalKey类型的Key范型为TextWidgetState（封装的文本&&有状态类）， 所以这个Key可以通过currentState方法调用到类里面的onPressed方法， 而onPressed方法刚好有调用setState来刷新局部状态。 "},"chapter1/screen_widget.html":{"url":"chapter1/screen_widget.html","title":"1.3：屏幕适配之组件应用","keywords":"","body":"分析 Flutter可用适配组件： Expanded、Flexible、Spacer、AspectRatio、Wrap、GridView、Table、SafeArea.... 案例1 分析： 一行，两边外边距为10，两个区块宽高相等，右边区块一个列也是宽高相等， 右边的下区块又是一行，两边相等，所有间隔都为10。 代码： new Container( // 容器组件 height: 200, // 设置默认高度 margin: EdgeInsets.symmetric(horizontal: 10.0),// 两边的外边距 child: new Row( // 一行显示 children: [ // 第一个区块 new Expanded( child: new Container( decoration: BoxDecoration( borderRadius: BorderRadius.all(Radius.circular(4.0)),// 圆角 color: Colors.amber.withOpacity(0.5)),// 颜色 ), ), // 间隔 new SizedBox(width: 10.0, height: 10.0), // 第二个区块 new Expanded( child: new Column( children: [ new Expanded( // 继续用Expanded撑开 child: new Container( decoration: BoxDecoration( borderRadius: BorderRadius.all(Radius.circular(4.0)),// 圆角 color: Colors.grey.withOpacity(0.5),// 颜色 ), ), ), new SizedBox(width: 10.0, height: 10.0),// 间隔10 new Expanded( child: new Row( children: [ new Expanded( child: new Container( decoration: BoxDecoration( borderRadius: BorderRadius.all( Radius.circular(4.0), ), color: Colors.red.withOpacity(0.5), ), ), ), new SizedBox(width: 10.0, height: 10.0), new Expanded( child: new Container( decoration: BoxDecoration( borderRadius: BorderRadius.all( Radius.circular(4.0), ), color: Colors.blueAccent.withOpacity(0.5)), ), ), ], ), ) ], ), ), // 为了使代码简单就不减少嵌套了 ], ), ) 这样就实现了Expanded自适应屏幕了，Expanded有个flex属性， 是负责控制占比空间的，不写则默认为1，值越大则占比越大。 Expanded 示例代码： new Container( height: 100, // 设置默认高度 margin: EdgeInsets.symmetric(horizontal: 10.0), child: new Row( children: [ // 第一个区块 new Expanded( flex: 1, child: new Container( decoration: BoxDecoration( borderRadius: BorderRadius.all(Radius.circular(4.0)), color: Colors.amber.withOpacity(0.5)), ), ), // 间隔 new SizedBox(width: 10.0, height: 10.0), // 第而个区块 new Expanded( flex: 2, child: new Container( decoration: BoxDecoration( borderRadius: BorderRadius.all( Radius.circular(4.0), ), color: Colors.blueAccent.withOpacity(0.5), ), ), ), // 为了使代码简单就不减少嵌套了 ], ), ); 第一个区块占比为1，第二个为2，则效果为： Spacer Spacer同Expanded一样具有flex属性，其含义和使用也是一模一样， 一般用于Row（行）或 Column（列）组件。 示例代码： new Column( children: [ new Container( height: 200, decoration: BoxDecoration( borderRadius: BorderRadius.all(Radius.circular(4.0)), color: Colors.amber.withOpacity(0.5), ), ), new Spacer(flex: 1), new Container( height: 200, decoration: BoxDecoration( borderRadius: BorderRadius.all(Radius.circular(4.0)), color: Colors.blueAccent.withOpacity(0.5), ), ), ], ) 效果： 我们给最下面那个区块也加个Spacer试试： new Column( children: [ ... new Container( ... ), new Spacer(flex: 1), ], ) 效果： 如果flex设置为2则会为第一个的两倍间隔。 "},"chapter1/screen_algorithm.html":{"url":"chapter1/screen_algorithm.html","title":"1.4：屏幕适配之屏幕算法","keywords":"","body":"屏幕适配之屏幕算法 既然是算法适配就必然少不了获取屏幕宽高，我们用的就是媒体查询（MediaQuery）， 下面是封装方法过后的，当然直接使用也是可以的： // 整屏宽度 double winWidth(BuildContext context) { return MediaQuery.of(context).size.width; } // 整屏高度 double winHeight(BuildContext context) { return MediaQuery.of(context).size.height; } 案例1： 蓝湖设计图有一张轮播图，宽度是 335 高度是 120，左右间隔是10， 如何使用屏幕算法适配全机型屏幕宽和高？ 分析： 左右间隔：设置margin然后左右10个间隔； 宽度：整宽减20，20就是左右的间隔； 高度：(宽度) * 120 / 335； 代码： new Container( height: (winWidth(context) - 20) * 120 / 335, width: winWidth(context) - 20, margin: EdgeInsets.symmetric(horizontal: 10.0), alignment: Alignment.center, decoration: BoxDecoration( borderRadius: BorderRadius.all(Radius.circular(4.0)), color: Colors.amber.withOpacity(0.5), ), child: new Text('模拟图片'), ), 效果 这就是一个普通的屏幕算法适配例子，他会一直按照这个比例，兼容所有机型。 案例2： 蓝湖设计图：未知数据数量有规则的列表视图，要求一行显示5个， 每个间隔为10（含上下），最外边距margin左右都为20，高度为50， 多出的数据继续往下排并向左对齐，适配任何机型。 分析： 左右间隔：设置margin然后左右20个间隔； 间隔和高：除最外边左右，内边都为10间隔，并包含上下，高度固定50； 对齐方式：对齐方式默认都为向左对齐； 组件：推荐Wrap，动态数据，依次撑开； 代码： class MyHomePage extends StatelessWidget { @override Widget build(BuildContext context) { return new Scaffold( appBar: new AppBar( title: new Text('Flutter高级进阶'), ), body: new Container( padding: EdgeInsets.symmetric(vertical: 20.0),// 为了保持美观给了上下价格20 color: Colors.amber.withOpacity(0.2), // 为了验证动态撑开给了背景 child: TestRoute(),// 主代码 ), ); } } class TestRoute extends StatefulWidget { @override _TestRouteState createState() => _TestRouteState(); } class _TestRouteState extends State { Widget buildItem(item) { return new Container( decoration: BoxDecoration( borderRadius: BorderRadius.all(Radius.circular(4.0)), // 圆角 color: Colors.blueAccent.withOpacity(0.5),// item颜色 ), height: 50.0, // 高度 alignment: Alignment.center, // item文本剧中 width: (winWidth(context) - 80) / 5, // 宽度 child: new Text('模拟'), ); } @override Widget build(BuildContext context) { return new Container( width: winWidth(context) - 40, // 宽度容器算法 margin: EdgeInsets.symmetric(horizontal: 20.0), child: new Wrap( spacing: 10.0, runSpacing: 10.0, children: [0, 1, 2, 3, 4, 5].map(buildItem).toList(), ), ); } } 效果 "},"chapter1/widget_offset.html":{"url":"chapter1/widget_offset.html","title":"1.5：根据控件位置弹出对话框","keywords":"","body":"根据控件位置弹出对话框 实现效果 首先我们要知道如何获取控件尺寸和位置信息， 插件必须渲染好, final RenderBox box = globalKey.currentContext.findRenderObject(); final size = box.size; // 获取尺寸 final topLeftPosition = box.localToGlobal(Offset.zero); return topLeftPosition.dy; 可以通过 context.size获取当前控件的尺寸和位置offset信息 下面是示例，通过context.size.height可以拿到child控件的高度 class HeightReporter extends StatelessWidget { final Widget child; HeightReporter({this.child}); @override Widget build(BuildContext context) { // 手势识别组件包裹一个Widget孩子 return new GestureDetector( child: child, // 获取尺寸高度并打印 onTap: () => print('Height is ${context.size.height}'), ); } } 正在更新中。。。。 "},"chapter2/":{"url":"chapter2/","title":"第二章：原理篇","keywords":"","body":"本章目录 Flutter的setState更新原理和流程 runApp入口执行 "},"chapter2/setstate.html":{"url":"chapter2/setstate.html","title":"1.1：setState更新原理和流程","keywords":"","body":"分析 Flutter状态类： StatelessWidget：无状态类，没有状态更新，界面一经创建无法更改； StatefulWidget：有状态类，当状态改变，调用setState()方法会触发StatefulWidget的UI状态更新，自定义继承StatefulWidget的子类须重写createState()方法。 也就是只有当我们的类是有状态类的时候才能进行状态刷新，setState也是在State（有状态类）类里 解析 ： framework.dart文件State类 调用 setState() 必须是没有调用过 dispose() 方法，不然出错，可通过mounted属性来判断调用此方法是否合法。 if (mounted) { setState(() {}); } setState方法 void setState(VoidCallback fn) { ... _element.markNeedsBuild(); } setState方法除了一些条件判断就是：_element.markNeedsBuild(); 那我们看看markNeedsBuild。 Element 类 markNeedsBuild方法 void markNeedsBuild() { assert(_debugLifecycleState != _ElementLifecycle.defunct); // 由于一帧做两次更新有点低效，所以在如果`_active=false` 的时候直接返回。 if (!_active) return;//返回 ... if (dirty) return; // 设置`_dirty = true ` _dirty = true; //调用scheduleBuildFor方法 owner.scheduleBuildFor(this); } 将 element 元素标记为“脏”,并把它添加到全局的“脏”链表里,以便在下一帧更新信号时更新. 这里的“ 脏”链表是待更新的链表，更新过后就不“脏”了。 那我们看看本方法最后调用的scheduleBuildFor方法。 BuildOwner 类 scheduleBuildFor方法 BuildOwner类是widget framework的管理类，它跟踪那些需要重新构建的 widget。 void scheduleBuildFor(Element element) { ... if (element._inDirtyList) { ... _dirtyElementsNeedsResorting = true; return; } if (!_scheduledFlushDirtyElements && onBuildScheduled != null) { _scheduledFlushDirtyElements = true; onBuildScheduled();//回调 } _dirtyElements.add(element);//把element添加到脏元素链表 element._inDirtyList = true; assert(() { if (debugPrintScheduleBuildForStacks) debugPrint('...dirty list is now: $_dirtyElements'); return true; }()); } 把一个 element 添加到 _dirtyElements 链表，主要为了方便当WidgetsBinding.drawFrame中调用 buildScope 的时候能够重构 element。onBuildScheduled()是一个 BuildOwner 的回调。 onBuildScheduled回调在WidgetsBinding的initInstances里初始化。 mixin WidgetsBinding on BindingBase, SchedulerBinding, GestureBinding, RendererBinding, SemanticsBinding { @override void initInstances() { super.initInstances(); _instance = this; // 这里 buildOwner.onBuildScheduled = _handleBuildScheduled; // 赋值onBuildScheduled window.onLocaleChanged = handleLocaleChanged;window.onAccessibilityFeaturesChanged = handleAccessibilityFeaturesChanged; SystemChannels.navigation.setMethodCallHandler(_handleNavigationInvocation); SystemChannels.system.setMessageHandler(_handleSystemMessage); FlutterErrorDetails.propertiesTransformers.add(transformDebugCreator); } } 可以看到Flutter应用启动过程初始化WidgetsBinding时buildOwner.onBuildScheduled回调等于了 _handleBuildScheduled，那现在来看看这个_handleBuildScheduled方法： void _handleBuildScheduled() { //调用ensureVisualUpdate ensureVisualUpdate(); } 可以看到调用ensureVisualUpdate方法，那我们继续走下去。 SchedulerBinding类ensureVisualUpdate方法 void ensureVisualUpdate() { switch (schedulerPhase) { case SchedulerPhase.idle: case SchedulerPhase.postFrameCallbacks: //当schedulerPhase为SchedulerPhase.idle， //SchedulerPhase.postFrameCallbacks时调用scheduleFrame() scheduleFrame(); return; case SchedulerPhase.transientCallbacks: case SchedulerPhase.midFrameMicrotasks: case SchedulerPhase.persistentCallbacks: return; } } schedulerPhase的初始值为SchedulerPhase.idle。SchedulerPhase是一个enum枚举类型， 分别case了SchedulerPhase 的 5 个枚举值： 状态 含义 idle 没有正在处理的帧，可能正在执行的是 WidgetsBinding.scheduleTask，scheduleMicrotask，Timer，事件 handlers，或者其他回调等 transientCallbacks SchedulerBinding.handleBeginFrame 过程， 处理动画状态更新 midFrameMicrotasks 处理 transientCallbacks 阶段触发的微任务（Microtasks） persistentCallbacks WidgetsBinding.drawFrame 和 SchedulerBinding.handleDrawFrame 过程，build/layout/paint 流水线工作 postFrameCallbacks 主要是清理和计划执行下一帧的工作 第二个case调用scheduleFrame()方法 那我们看看scheduler/binding.dart文件的SchedulerBinding类scheduleFrame()方法 void scheduleFrame() { // 这个判断表示只有当APP处于可见状态才会准备调度下一帧方法 if (_hasScheduledFrame || !_framesEnabled) return; assert(() { if (debugPrintScheduleFrameStacks) debugPrintStack( label: 'scheduleFrame() called. Current phase is $schedulerPhase.'); return true; }()); //调用Window 的scheduleFrame方法是一个 native 方法 window.scheduleFrame(); _hasScheduledFrame = true; } 这里的 window.scheduleFrame()方法是一个Native方法， 由于本人并没有扎实的原生经验所以下方借鉴了袁辉辉大佬的部分讲解， lib/ui/window.dart文件 Window类 (Native) void scheduleFrame() native 'Window_scheduleFrame'; window是Flutter引擎中跟图形相关接口打交道的核心类。 ScheduleFrame(C++) window.cc文件 void ScheduleFrame(Dart_NativeArguments args) { // 看下方 RuntimeController::ScheduleFrame UIDartState::Current()->window()->client()->ScheduleFrame(); } 通过RegisterNatives()完成native方法的注册，“Window_scheduleFrame”所对应的native方法如上所示。 RuntimeController::ScheduleFrame 所在文件：flutter/runtime/runtime_controller.cc void RuntimeController::ScheduleFrame() { client_.ScheduleFrame(); // 看下面Engine::ScheduleFrame } Engine::ScheduleFrame 所在文件：flutter/shell/common/engine.cc void Engine::ScheduleFrame(bool regenerate_layer_tree) { animator_->RequestFrame(regenerate_layer_tree); } 这里推荐查看袁辉辉大佬的：Flutter渲染机制—UI线程 文中小节[2.1]介绍Engine::ScheduleFrame()经过层层调用，最终会注册Vsync回调。 等待下一次vsync信号的到来， 然后再经过层层调用最终会调用到Window::BeginFrame()。 Window::BeginFrame 所在文件：flutter/lib/ui/window/window.cc void Window::BeginFrame(fml::TimePoint frameTime) { std::shared_ptr dart_state = library_.dart_state().lock(); if (!dart_state) return; tonic::DartState::Scope scope(dart_state); int64_t microseconds = (frameTime - fml::TimePoint()).ToMicroseconds(); DartInvokeField(library_.value(), \"_beginFrame\", { Dart_NewInteger(microseconds), }); //执行MicroTask UIDartState::Current()->FlushMicrotasksNow(); DartInvokeField(library_.value(), \"_drawFrame\", {}); } Window::BeginFrame()过程主要工作： 执行_beginFrame 执行FlushMicrotasksNow 执行_drawFrame 可见，Microtask位于beginFrame和drawFrame之间，那么Microtask的耗时会影响ui绘制过程。 handleBeginFrame 文件所在: lib/src/scheduler/binding.dart SchedulerBinding类 void handleBeginFrame(Duration rawTimeStamp) { Timeline.startSync('Frame', arguments: timelineWhitelistArguments); _firstRawTimeStampInEpoch ??= rawTimeStamp; _currentFrameTimeStamp = _adjustForEpoch(rawTimeStamp ?? _lastRawTimeStamp); if (rawTimeStamp != null) _lastRawTimeStamp = rawTimeStamp; profile(() { _profileFrameNumber += 1; _profileFrameStopwatch.reset(); _profileFrameStopwatch.start(); }); //此时阶段等于SchedulerPhase.idle; _hasScheduledFrame = false; try { Timeline.startSync('Animate', arguments: timelineWhitelistArguments); _schedulerPhase = SchedulerPhase.transientCallbacks; //执行动画的回调方法 final Map callbacks = _transientCallbacks; _transientCallbacks = {}; callbacks.forEach((int id, _FrameCallbackEntry callbackEntry) { if (!_removedIds.contains(id)) _invokeFrameCallback(callbackEntry.callback, _currentFrameTimeStamp, callbackEntry.debugStack); }); _removedIds.clear(); } finally { _schedulerPhase = SchedulerPhase.midFrameMicrotasks; } } 该方法主要功能是遍历_transientCallbacks，执行相应的Animate操作， 可通过scheduleFrameCallback()/cancelFrameCallbackWithId()来完成添加和删除成员， 再来简单看看这两个方法。 handleDrawFrame 文件所在：lib/src/scheduler/binding.dart SchedulerBinding类 void handleDrawFrame() { assert(_schedulerPhase == SchedulerPhase.midFrameMicrotasks); Timeline.finishSync(); // 标识结束\"Animate\"阶段 try { _schedulerPhase = SchedulerPhase.persistentCallbacks; //执行PERSISTENT FRAME回调 for (FrameCallback callback in _persistentCallbacks) _invokeFrameCallback(callback, _currentFrameTimeStamp); _schedulerPhase = SchedulerPhase.postFrameCallbacks; // 执行POST-FRAME回调 final List localPostFrameCallbacks = List.from(_postFrameCallbacks); _postFrameCallbacks.clear(); for (FrameCallback callback in localPostFrameCallbacks) _invokeFrameCallback(callback, _currentFrameTimeStamp); } finally { _schedulerPhase = SchedulerPhase.idle; Timeline.finishSync(); //标识结束”Frame“阶段 profile(() { _profileFrameStopwatch.stop(); _profileFramePostEvent(); }); _currentFrameTimeStamp = null; } } 该方法主要功能： 遍历_persistentCallbacks，执行相应的回调方法，可通过addPersistentFrameCallback()注册，一旦注册后不可移除，后续每一次frame回调都会执行； 遍历_postFrameCallbacks，执行相应的回调方法，可通过addPostFrameCallback()注册，handleDrawFrame()执行完成后会清空_postFrameCallbacks内容。 UI 的绘制逻辑【附加】 UI 的绘制逻辑是在 Render 树中实现的，所以这里还来细看 RendererBinding 的逻辑。 RendererBinding 【附加】 void initInstances() { ... //监听Window对象的事件 ui.window ..onMetricsChanged = handleMetricsChanged ..onTextScaleFactorChanged = handleTextScaleFactorChanged ..onSemanticsEnabledChanged = _handleSemanticsEnabledChanged ..onSemanticsAction = _handleSemanticsAction; //添加PersistentFrameCallback addPersistentFrameCallback(_handlePersistentFrameCallback); } addPersistentFrameCallback 中添加 _handlePersistentFrameCallback 最终调用了 drawFrame 而 WidgetsBinding 重写了 RendererBinding 中的 drawFrame() 方法。最终发现我们又回到了 WidgetsBinding 这个类中，在 WidgetsBinding 中 drawFrame 的实现如下： @override void drawFrame() { ... try { if (renderViewElement != null) // 重构需要更新的element buildOwner.buildScope(renderViewElement); super.drawFrame(); //调用RendererBinding的drawFrame()方法 buildOwner.finalizeTree(); } } 在上面 scheduleBuildFor 方法介绍中有提到：\"scheduleBuildFor 是把一个 element 添加到 _dirtyElements 链表，以便当[WidgetsBinding.drawFrame]中调用 buildScope 的时候能够重构 element。onBuildScheduled()是一个 BuildOwner 的回调\"。在 drawFrame 中调用 buildOwner.buildScope(renderViewElement)更新 elements。 void buildScope(Element context, [ VoidCallback callback ]) { ... while (index 得出 条件判断 1.生命周期判断 2.是否可以进行刷新：mounted 添加脏链表 _dirty = true 1.“脏”链表是待更新的链表 2.更新过后就不“脏”了 3._active=false 的时候直接返回 管理类 1.告诉管理类方法自己需要被重新构建： owner.scheduleBuildFor(this) 调用 window.scheduleFrame() =》native 方法 RegisterNatives()完成native方法的注册 最终会注册Vsync回调。 等待下一次vsync信号的到来， 然后再经过层层调用最终会调用到 Window::BeginFrame() UI 的绘制逻辑是在 Render 树中实现的 更新帧信号来临从而刷新需要重构的界面 在 drawFrame 中调用 buildOwner.buildScope(renderViewElement)更新 elements "},"chapter2/run_app.html":{"url":"chapter2/run_app.html","title":"1.2：runApp入口执行","keywords":"","body":"runApp 我们平常的App入口都是： void main() => runApp(MyApp()); 那runApp到底做了什么，怎么来执行这个MyApp的？ void runApp(Widget app) { WidgetsFlutterBinding.ensureInitialized() //确保初始化 ..attachRootWidget(app) //附加根小部件 ..scheduleWarmUpFrame(); //安排热身帧 } runApp方法接收一个Widget类型app值，这个值是我们需要显示的界面Widget， 然后我们看到第一个是调用了WidgetsFlutterBinding.ensureInitialized()， // WidgetsFlutterBinding('flutter/lib/src/widgets/binding.dart') class WidgetsFlutterBinding extends BindingBase with GestureBinding, ServicesBinding, SchedulerBinding, PaintingBinding, SemanticsBinding, RendererBinding, WidgetsBinding { static WidgetsBinding ensureInitialized() { if (WidgetsBinding.instance == null) WidgetsFlutterBinding(); return WidgetsBinding.instance; } } 这WidgetsFlutterBinding是一个单例类，WidgetsFlutterBinding继承了BindingBase并且with了大量的mixin, 官方给的注释： 基于Widgets框架的应用程序的具体绑定。 这是将框架绑定到Flutter引擎的粘合剂。 也就是说这个类是将Widget架构和Flutter底层Engine连接的桥梁。 那么 ensureInitialized() 就是负责初始化以及返回实例的。 Widget到Element到RenderObject的流程 初始化后就会继续调用attachRootWidget(app)： // WidgetsBinding (flutter/lib/src/widgets/binding.dart) // 取得一个小部件并将其附加到[renderViewElement] // 该方法完成了Widget到Element到RenderObject的整个关联过程 void attachRootWidget(Widget rootWidget) { _renderViewElement = RenderObjectToWidgetAdapter( container: renderView, debugShortDescription: '[root]', child: rootWidget, ).attachToRenderTree(buildOwner, renderViewElement); // 看下个方法讲解 } 就是将传入的Widget包装到RenderObjectToWidgetAdapter，它继承自RenderObjectWidget， 负责将Widget、Element、RenderObject三者关联起来，其中的RenderObject对应前面初始化操作中创建的renderView。 其中renderView和_renderViewElement为WidgetsFlutterBinding的成员， 可以看出每个app只存在一个renderViewElement和renderView，并且一一对应。 attachToRenderTree // RenderObjectToWidgetAdapter（flutter/lib/src/widgets/binding.dart） // 此方法负责创建根Element，也就是RenderObjectToWidgetElement /// 官方注释： ///给这个小部件充气，然后将结果[RenderObject]设置为 /// [container]的子级。 ///如果`element`为null，则此函数将创建一个新元素。 除此以外， ///给定的元素将安排更新以切换到此小部件。 ///可以看出Element只会创建一次，后面会进行复用 /// /// [runApp]用于引导应用程序。 RenderObjectToWidgetElement attachToRenderTree (BuildOwner owner, [ RenderObjectToWidgetElement element ]) { // 如果`element`为null if (element == null) { // 创建根Element，RenderObjectToWidgetElement owner.lockState(() { element = createElement(); assert(element != null); element.assignOwner(owner); }); owner.buildScope(element, () { // 这里会根据WidgetTree构建ElementTree element.mount(null, null); // 看下面的mount方法讲解 }); } else { // 则此函数将创建一个新元素 element._newWidget = this; element.markNeedsBuild(); // markNeedsBuild在setState更新原理和流程有讲到 } return element; } mount // RenderObjectToWidgetAdapter（flutter/lib/src/widgets/binding.dart） @override void mount(Element parent, dynamic newSlot) { assert(parent == null); // 断言接收的parent等于空 super.mount(parent, newSlot); _rebuild(); } _rebuild // RenderObjectToWidgetAdapter（flutter/lib/src/widgets/binding.dart） void _rebuild() { try { // 实际上是调用updateChild更新ElementTree _child = updateChild(_child, widget.child, _rootChildSlot); // 查看【updateChild】 assert(_child != null); } catch (exception, stack) { // 红屏产生的地方 final FlutterErrorDetails details = FlutterErrorDetails( exception: exception, stack: stack, library: 'widgets library', context: ErrorDescription('attaching to the render tree'), ); // 这里打印了错误栈 FlutterError.reportError(details); // 这里就是创建了红屏的Widget，显示在屏幕上 // 自定义ErrorWidget看下一个方法 final Widget error = ErrorWidget.builder(details); _child = updateChild(null, error, _rootChildSlot);// 查看【updateChild】 } } 自定义ErrorWidget报错页面 void main() async { runApp(MyApp()); /// 自定义报错页面 ErrorWidget.builder = (FlutterErrorDetails flutterErrorDetails) { debugPrint(flutterErrorDetails.toString()); return new Center(child: new Text(\"App错误，快去反馈给作者!\")); }; } updateChild() 更新ElementTree 实际上该方法只执行了updateChild()，该方法至关重要，ElementTree的生成主要就在方法中实现， 我们来细看一下代码，注意代码中添加的注释： // child表示要更新的Element，newWidget表示对应Element的Widget， // newSlot用来标识Element的所在位置，返回该位置对应的新Element @protected Element updateChild(Element child, Widget newWidget, dynamic newSlot) { assert(() { // Debug下保证一个GlobalKey只对应一个Widget if (newWidget != null && newWidget.key is GlobalKey) { final GlobalKey key = newWidget.key; key._debugReserveFor(this); } return true; }()); if (newWidget == null) { // 如果newWidget为空，child非空表示需要移除旧Element if (child != null) deactivateChild(child); // 将此Element的位置设为null return null; } if (child != null) { // 都不为空且是相同Widget，更新位置标识即可 if (child.widget == newWidget) { if (child.slot != newSlot) updateSlotForChild(child, newSlot); // 更新后返回原Element return child; } // 若不是相同Widget则判断是否有相同的类型和相同的Key，是的话则更新Widget信息到Element if (Widget.canUpdate(child.widget, newWidget)) { if (child.slot != newSlot) updateSlotForChild(child, newSlot); child.update(newWidget); assert(child.widget == newWidget); assert(() { child.owner._debugElementWasRebuilt(child); return true; }()); // 更新后返回原Element return child; } // 若不符合更新的要求，则抛弃掉原Element，抛弃掉的Element会被回收到`_inactiveElements`列表中，不会立即被销毁 deactivateChild(child); assert(child._parent == null); } // 其他情况下需要创建新的Element return inflateWidget(newWidget, newSlot); //查看【inflateWidget】 } 总结 newWidget等于空 newWidget不等于空 child等于空 返回null. 返回新 [Element]. child不等于空 旧child被删除，返回空. 可能会更新旧的子级，返回子级或新的[Element]. inflateWidget ///为给定的小部件创建一个元素，并将其添加为该元素的子元素给定插槽中的元素。 /// ///此方法通常由[updateChild]调用，但可以调用直接由需要更精细地控制创建的子类元素。 /// ///如果给定的小部件具有全局键并且已经存在一个元素有一个带有该全局键的小部件，此函数将重用该元素 ///（可能从树中的其他位置移植或重新激活从无效元素列表中获取），而不是创建一个新元素。 /// ///此函数返回的元素将已经被挂载并将处于“活动”生命周期状态。 @protected Element inflateWidget(Widget newWidget, dynamic newSlot) { assert(newWidget != null); final Key key = newWidget.key; if (key is GlobalKey) { // 先使用key去被回收的列表中看看是否有可以复用的Element final Element newChild = _retakeInactiveElement(key, newWidget); if (newChild != null) { assert(newChild._parent == null); assert(() { _debugCheckForCycles(newChild); return true; }()); newChild._activateWithParent(this, newSlot); // 找到后就复用被回收的Element，并且更新它的Child final Element updatedChild = updateChild(newChild, newWidget, newSlot); assert(newChild == updatedChild); return updatedChild; } } // 没有可以复用的Element了，创建新的 final Element newChild = newWidget.createElement(); assert(() { _debugCheckForCycles(newChild); return true; }()); // mount安装新的Element newChild.mount(this, newSlot); assert(newChild._debugLifecycleState == _ElementLifecycle.active); // 返回新的child return newChild; } 新创建的Element继续调用mount，于是又会触发新一轮的updateChild， 最终对应WidgetTree的整个ElementTree就构建完成了。 更新中。。。 "}}