{"./":{"url":"./","title":"简介","keywords":"","body":"作者 q1，一年Flutter工作经验，企业内部Flutter培训讲师，Flutter开发组长， Flutter教程网 创办者，微信公众号\"Flutter前线\"小编， FlutterCandies开源组织成员，具有： wechat_flutter， ncov_2019， nav_router等开源项目作品， 视频课程：Flutter实用例子进阶课程 ， 高仿谷歌翻译项目课程， 目前就职于广州某创业公司， 持续对Flutter社区输出文章资源，主要关注移动端行业发展和技术更新迭代，不断进步。 简介 本书主要讲解Flutter进阶，深入原理，以及工作所可能遇到的技术栈和问题解决方案、面试中 可能遇到的问题，以实战角度进行：文案、思维导图、代码示例、工作原理、使用方式进行讲解， 可帮助开发者快速进阶flutter技术。 章节介绍 本书分为多个章节，不确定性，会一直更，直到完善，然后固定章节，目前已有章节： 进阶篇、原理篇、Flutter面试题。 本书暂未想过发版实体书，主要发布电子版供大家学习参考。 持续更新中。。。敬请期待！ "},"chapter0/":{"url":"chapter0/","title":"环境搭建","keywords":"","body":"本章目录 Windows环境搭建 Mac OS环境搭建 Linux环境搭建 "},"chapter1/":{"url":"chapter1/","title":"第1章：进阶篇","keywords":"","body":"本章目录 Flutter的生命周期 屏幕适配之组件应用 屏幕适配之屏幕算法 根据控件位置弹出对话框 App主题色控制及夜间模式 App内更新并自动打开安装 "},"chapter1/life_cycle.html":{"url":"chapter1/life_cycle.html","title":"1.1：生命周期","keywords":"","body":"生命周期 Flutter生命周期相对于android的Activity，ta存在于framework.dart的State类， 实测 写个有状态类并混入WidgetsBindingObserver配合监听特殊状态及其一个按钮，调用setState， 给生命周期的方法新增打印： import 'package:flutter/material.dart'; void main() => runApp(new MyApp()); class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return new MaterialApp( title: '生命周期', home: new LiftCycle(), ); } } class LiftCycle extends StatefulWidget { @override _LiftCycleState createState() => _LiftCycleState(); } class _LiftCycleState extends State with WidgetsBindingObserver { int count = 0; @override void initState() { super.initState(); WidgetsBinding.instance.addObserver(this); print('初始化 initState'); } @override void didUpdateWidget(LiftCycle oldWidget) { super.didUpdateWidget(oldWidget); print('组件更新 didUpdateWidget'); } @override void reassemble() { super.reassemble(); print('重新安装 reassemble'); } @override void deactivate() { super.deactivate(); print('停用 deactivate'); } @override void dispose() { super.dispose(); WidgetsBinding.instance.removeObserver(this); print('销毁 dispose'); } @override void didChangeAppLifecycleState(AppLifecycleState state) { super.didChangeAppLifecycleState(state); print('特殊状态 state：$state'); } @override void setState(fn) { super.setState(fn); print('状态刷新 setState'); } @override Widget build(BuildContext context) { return new Scaffold( appBar: new AppBar(title: new Text('生命周期')), body: new Center( child: new FlatButton( onPressed: () => setState(() => count++), child: new Text('$count'), ), ), ); } @override void didChangeDependencies() { super.didChangeDependencies(); print('依赖改变 didChangeDependencies'); } } 然后我们现在来看看打印流程，正常打开App什么都不操作，就打印了： I/flutter (15867): 初始化 initState I/flutter (15867): 依赖改变 didChangeDependencies I/flutter (15867): 重新安装 reassemble I/flutter (15867): 组件更新 didUpdateWidget 热重载打印： I/flutter (16141): 重新安装 reassemble I/flutter (16141): 组件更新 didUpdateWidget Reloaded 0 of 468 libraries in 186ms. 点击按钮打印： I/flutter (16141): 状态刷新 setState // count也+1了，说明重新调用过build。 流程图 图解主要部分： 1.构建（build）； 2.如果用户调用了setState时则状态刷新，重新build； 3.如果销毁先停用然后dispose销毁再结束； 构造函数 构造函数不属于生命周期，必然是要第一个调用的，也就是调用前State的widget属性为空。 initState 初始化 当此对象插入树中时调用，框架会调用一次此方法并不会再次重复执行， 如果[State]的[build]方法依赖于本身可以更改状态的对象，例如[ChangeNotifier]或[Stream]， 或者某些其他可以订阅的对象接收通知，可以在此方法订阅，但记得去dispose取消订阅； didChangeDependencies 依赖改变 顾名思义，依赖项更改时调用，但也会在initState之后调用， 在这个方法调用[BuildContext.inheritFromWidgetOfExactType]是安全的。 build 构建 会在以下场景调用： initState()之后； didUpdateWidget()之后； setState()之后。 didChangeDependencies()之后。 State对象从树中一个位置移除后会调用deactivate，然后又重新插入到树的其它位置之后。 reassemble 重新安装 专门为了开发调试而提供的，在热重载(hot reload)时会被调用，此回调在Release模式下永远不会被调用。 didUpdateWidget 组件更新 当组件的状态改变的时候就会调用didUpdateWidget(),比如调用了setState()， 在widget重新构建时，Flutter framework会调用Widget.canUpdate来检测Widget树中同一位置的新旧节点， 然后决定是否需要更新，如果Widget.canUpdate返回true则会调用此回调。正如之前所述，Widget.canUpdate会在 新旧widget的key和runtimeType同时相等时会返回true，也就是说在新旧widget的key和runtimeType同时相等时didUpdateWidget()就会被调用。 deactivate 暂停 State对象从树中被移除时（在dispose之前），会调用这个函数来将对象暂停。 dispose 销毁 当State对象被销毁时调用，通常在此回调中释放资源和移除监听。 【 特殊状态 】 我们自定义的State类混入了WidgetsBindingObserver，所以可以使用他的暂停和恢复， 初始化： @override void initState() { super.initState(); WidgetsBinding.instance.addObserver(this); // 在这初始化了 print('初始化 initState'); } 销毁： @override void dispose() { super.dispose(); WidgetsBinding.instance.removeObserver(this); // 在这销毁 print('销毁 dispose'); } 使用： @override void didChangeAppLifecycleState(AppLifecycleState state) { super.didChangeAppLifecycleState(state); print('特殊状态 state：$state'); } 这个didChangeAppLifecycleState是WidgetsBindingObserver类的一个方法， 可以用来判断当前的状态是在前台还是后台。 这个方法接收一个AppLifecycleState类型的枚举： 枚举值 含义 resumed 程序可见，并响应用户输入。 inactive 处于非活动状态，未收到用户输入。 paused 程序当前不可见，不响应用户输入，并且在后台运行。 suspending 程序将暂时暂停。 AppLifecycleState实测 当App返回到桌面或者其他不可见状态，但并未结束： I/flutter ( 2428): 特殊状态 state：AppLifecycleState.inactive I/flutter ( 2428): 特殊状态 state：AppLifecycleState.paused 当App回到可见状态： I/flutter ( 2428): 特殊状态 state：AppLifecycleState.inactive I/flutter ( 2428): 特殊状态 state：AppLifecycleState.resumed 流程图： "},"chapter1/screen_widget.html":{"url":"chapter1/screen_widget.html","title":"1.2：屏幕适配之组件应用","keywords":"","body":"分析 Flutter可用适配组件： Expanded、Flexible、Spacer、AspectRatio、Wrap、GridView、Table、SafeArea.... 案例1 分析： 一行，两边外边距为10，两个区块宽高相等，右边区块一个列也是宽高相等， 右边的下区块又是一行，两边相等，所有间隔都为10。 代码： new Container( // 容器组件 height: 200, // 设置默认高度 margin: EdgeInsets.symmetric(horizontal: 10.0),// 两边的外边距 child: new Row( // 一行显示 children: [ // 第一个区块 new Expanded( child: new Container( decoration: BoxDecoration( borderRadius: BorderRadius.all(Radius.circular(4.0)),// 圆角 color: Colors.amber.withOpacity(0.5)),// 颜色 ), ), // 间隔 new SizedBox(width: 10.0, height: 10.0), // 第二个区块 new Expanded( child: new Column( children: [ new Expanded( // 继续用Expanded撑开 child: new Container( decoration: BoxDecoration( borderRadius: BorderRadius.all(Radius.circular(4.0)),// 圆角 color: Colors.grey.withOpacity(0.5),// 颜色 ), ), ), new SizedBox(width: 10.0, height: 10.0),// 间隔10 new Expanded( child: new Row( children: [ new Expanded( child: new Container( decoration: BoxDecoration( borderRadius: BorderRadius.all( Radius.circular(4.0), ), color: Colors.red.withOpacity(0.5), ), ), ), new SizedBox(width: 10.0, height: 10.0), new Expanded( child: new Container( decoration: BoxDecoration( borderRadius: BorderRadius.all( Radius.circular(4.0), ), color: Colors.blueAccent.withOpacity(0.5)), ), ), ], ), ) ], ), ), // 为了使代码简单就不减少嵌套了 ], ), ) 这样就实现了Expanded自适应屏幕了，Expanded有个flex属性， 是负责控制占比空间的，不写则默认为1，值越大则占比越大。 Expanded 示例代码： new Container( height: 100, // 设置默认高度 margin: EdgeInsets.symmetric(horizontal: 10.0), child: new Row( children: [ // 第一个区块 new Expanded( flex: 1, child: new Container( decoration: BoxDecoration( borderRadius: BorderRadius.all(Radius.circular(4.0)), color: Colors.amber.withOpacity(0.5)), ), ), // 间隔 new SizedBox(width: 10.0, height: 10.0), // 第而个区块 new Expanded( flex: 2, child: new Container( decoration: BoxDecoration( borderRadius: BorderRadius.all( Radius.circular(4.0), ), color: Colors.blueAccent.withOpacity(0.5), ), ), ), // 为了使代码简单就不减少嵌套了 ], ), ); 第一个区块占比为1，第二个为2，则效果为： Spacer Spacer同Expanded一样具有flex属性，其含义和使用也是一模一样， 一般用于Row（行）或 Column（列）组件。 示例代码： new Column( children: [ new Container( height: 200, decoration: BoxDecoration( borderRadius: BorderRadius.all(Radius.circular(4.0)), color: Colors.amber.withOpacity(0.5), ), ), new Spacer(flex: 1), new Container( height: 200, decoration: BoxDecoration( borderRadius: BorderRadius.all(Radius.circular(4.0)), color: Colors.blueAccent.withOpacity(0.5), ), ), ], ) 效果： 我们给最下面那个区块也加个Spacer试试： new Column( children: [ ... new Container( ... ), new Spacer(flex: 1), ], ) 效果： 如果flex设置为2则会为第一个的两倍间隔。 提示 Spacer设置在未知宽高的Row或者Column会无效或者报错，如果有设宽高就可以无需设置mainAxisAlignment就能实现 我们想要的各种效果了，当然，在Row或者Column里使用Expanded包裹我们的组件也是上级的Row或者Column一定要有宽高， 否则会报错，可滑动组件内不能直接放Expanded，例如：\"ListView里放Expanded\"，具体大家可以自己去尝试。 "},"chapter1/screen_algorithm.html":{"url":"chapter1/screen_algorithm.html","title":"1.3：屏幕适配之屏幕算法","keywords":"","body":"屏幕适配之屏幕算法 既然是算法适配就必然少不了获取屏幕宽高，我们用的就是媒体查询（MediaQuery）， 下面是封装方法过后的，当然直接使用也是可以的： // 整屏宽度 double winWidth(BuildContext context) { return MediaQuery.of(context).size.width; } // 整屏高度 double winHeight(BuildContext context) { return MediaQuery.of(context).size.height; } 案例1： 蓝湖设计图有一张轮播图，宽度是 335 高度是 120，左右间隔是10， 如何使用屏幕算法适配全机型屏幕宽和高？ 分析： 左右间隔：设置margin然后左右10个间隔； 宽度：整宽减20，20就是左右的间隔； 高度：(宽度) * 120 / 335； 代码： new Container( height: (winWidth(context) - 20) * 120 / 335, width: winWidth(context) - 20, margin: EdgeInsets.symmetric(horizontal: 10.0), alignment: Alignment.center, decoration: BoxDecoration( borderRadius: BorderRadius.all(Radius.circular(4.0)), color: Colors.amber.withOpacity(0.5), ), child: new Text('模拟图片'), ), 效果 这就是一个普通的屏幕算法适配例子，他会一直按照这个比例，兼容所有机型。 案例2： 蓝湖设计图：未知数据数量有规则的列表视图，要求一行显示5个， 每个间隔为10（含上下），最外边距margin左右都为20，高度为50， 多出的数据继续往下排并向左对齐，适配任何机型。 分析： 左右间隔：设置margin然后左右20个间隔； 间隔和高：除最外边左右，内边都为10间隔，并包含上下，高度固定50； 对齐方式：对齐方式默认都为向左对齐； 组件：推荐Wrap，动态数据，依次撑开； 代码： class MyHomePage extends StatelessWidget { @override Widget build(BuildContext context) { return new Scaffold( appBar: new AppBar( title: new Text('Flutter高级进阶'), ), body: new Container( padding: EdgeInsets.symmetric(vertical: 20.0),// 为了保持美观给了上下价格20 color: Colors.amber.withOpacity(0.2), // 为了验证动态撑开给了背景 child: TestRoute(),// 主代码 ), ); } } class TestRoute extends StatefulWidget { @override _TestRouteState createState() => _TestRouteState(); } class _TestRouteState extends State { Widget buildItem(item) { return new Container( decoration: BoxDecoration( borderRadius: BorderRadius.all(Radius.circular(4.0)), // 圆角 color: Colors.blueAccent.withOpacity(0.5),// item颜色 ), height: 50.0, // 高度 alignment: Alignment.center, // item文本剧中 width: (winWidth(context) - 80) / 5, // 宽度 child: new Text('模拟'), ); } @override Widget build(BuildContext context) { return new Container( width: winWidth(context) - 40, // 宽度容器算法 margin: EdgeInsets.symmetric(horizontal: 20.0), child: new Wrap( spacing: 10.0, runSpacing: 10.0, children: [0, 1, 2, 3, 4, 5].map(buildItem).toList(), ), ); } } 效果 原理： 其实这就是最基本的屏幕算法，使用的是小学数学里的常用加减乘除，用了多少就用整个的减多少， 很常见也很简单很实用，在企业开发中用到这套就已经能完全适配所有屏幕了，主要是灵活应变。 不过能用组件来适配的还是建议使用组件。 "},"chapter1/widget_offset.html":{"url":"chapter1/widget_offset.html","title":"1.4：根据控件位置弹出对话框","keywords":"","body":"根据控件位置弹出对话框 实现效果 首先我们要知道如何获取控件尺寸和位置信息， 插件必须渲染好, final RenderBox box = globalKey.currentContext.findRenderObject(); final size = box.size; // 获取尺寸 final topLeftPosition = box.localToGlobal(Offset.zero); return topLeftPosition.dy; 可以通过 context.size获取当前控件的尺寸和位置offset信息 下面是示例，通过context.size.height可以拿到child控件的高度 class HeightReporter extends StatelessWidget { final Widget child; HeightReporter({this.child}); @override Widget build(BuildContext context) { // 手势识别组件包裹一个Widget孩子 return new GestureDetector( child: child, // 获取尺寸高度并打印 onTap: () => print('Height is ${context.size.height}'), ); } } 开始Demo 首先我们使用ListView.builder来创建很多靠右的按钮，不写itemCount就是无限循环的， 然后这些按钮就是我们的点击事件按钮，负责弹出对话框的； new ListView.builder(itemBuilder: button) 然后按钮我们来给事件： Widget button(context, index) { return new Align( alignment: Alignment.centerRight, child: new IconButton( icon: new Icon(Icons.more_horiz, color: Colors.black), onPressed: () { // 使用路由跳转方式 Navigator.push( context, new PopRoute( child: new Popup( btnContext: context, onClick: (v) => debugPrint('你点击了$v'), // 传到外面来的回调事件 ), ), ); }, ), ); } 事件给的是路由跳转，然后PopRoute是我们自定义的路由，它必须要继承PopupRoute类： class PopRoute extends PopupRoute { // push的耗时，milliseconds为毫秒 final Duration _duration = Duration(milliseconds: 300); // 接收一个child，也就是我们push的内容。 Widget child; // 构造方法 PopRoute({@required this.child}); @override Color get barrierColor => null; @override bool get barrierDismissible => true; @override String get barrierLabel => null; @override Widget buildPage(BuildContext context, Animation animation, Animation secondaryAnimation) { return child; } @override Duration get transitionDuration => _duration; } 然后push出来的内容就是Popup类，Popup类接收一个上下文context，用来获取点击的控件的位置， OnItem就是我们的自定义类型声明回调，传了个String类型的值回去给上级接收，这个String类型的值就是赞或评论： // 类型声明回调 typedef OnItem = Function(String value); class Popup extends StatefulWidget { final BuildContext btnContext; final OnItem onClick; //点击child事件 Popup({this.btnContext, this.onClick}); PopupState createState() => PopupState(); } class PopupState extends State { // 声明对象 RenderBox button; RenderBox overlay; RelativeRect position; @override void initState() { super.initState(); // 找到并渲染对象button button = widget.btnContext.findRenderObject(); // 找到并渲染对象overlay overlay = Overlay.of(widget.btnContext).context.findRenderObject(); // 位置设置 position = RelativeRect.fromRect( Rect.fromPoints( button.localToGlobal(Offset.zero, ancestor: overlay), button.localToGlobal(Offset.zero, ancestor: overlay), ), Offset.zero & overlay.size, ); } // item构建 Widget itemBuild(item) { // 字体样式 TextStyle labelStyle = TextStyle(color: Colors.white); return new Expanded( child: new FlatButton( //点击Item onPressed: () { // 如果没接收也返回的花就会报错，所以这里需要判断 if (widget.onClick != null) { Navigator.of(context).pop(); widget.onClick(item); // 事件返回String类型的值 } }, child: new Text(item, style: labelStyle), ), ); } @override Widget build(BuildContext context) { return new Material( type: MaterialType.transparency, // Material类型设置 child: new GestureDetector( child: new Stack( children: [ new Container( // 设置一个容器组件，是整屏幕的。 width: MediaQuery.of(context).size.width, height: MediaQuery.of(context).size.height, color: Colors.transparent, // 它的颜色为透明色 ), new Positioned( child: new Container( width: 200, height: 36, decoration: BoxDecoration( color: Color.fromRGBO(75, 75, 75, 1.0), borderRadius: BorderRadius.all(Radius.circular(4.0)), // 圆角 ), child: new Row(children: ['点赞', '评论'].map(itemBuild).toList()), ), top: position.top, // 顶部位置 right: position.right, // 右边位置 ) ], ), onTap: () => Navigator.of(context).pop(), //点击空白处直接返回 ), ); } } 完整代码 import 'package:flutter/material.dart'; void main() => runApp(MyApp()); class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return new MaterialApp( title: 'Flutter高级进阶', home: new MyHomePage(), ); } } class MyHomePage extends StatelessWidget { Widget button(context, index) { return new Align( alignment: Alignment.centerRight, child: new IconButton( icon: new Icon(Icons.more_horiz, color: Colors.black), onPressed: () { // 使用路由跳转方式 Navigator.push( context, new PopRoute( child: new Popup( btnContext: context, onClick: (v) => debugPrint('你点击了$v'), // 传到外面来的回调事件 ), ), ); }, ), ); } @override Widget build(BuildContext context) { return new Scaffold( appBar: new AppBar(title: new Text('Flutter高级进阶')), body: new ListView.builder(itemBuilder: button), ); } } class PopRoute extends PopupRoute { // push的耗时，milliseconds为毫秒 final Duration _duration = Duration(milliseconds: 300); // 接收一个child，也就是我们push的内容。 Widget child; // 构造方法 PopRoute({@required this.child}); @override Color get barrierColor => null; @override bool get barrierDismissible => true; @override String get barrierLabel => null; @override Widget buildPage(BuildContext context, Animation animation, Animation secondaryAnimation) { return child; } @override Duration get transitionDuration => _duration; } // 类型声明回调 typedef OnItem = Function(String value); class Popup extends StatefulWidget { final BuildContext btnContext; final OnItem onClick; //点击child事件 Popup({this.btnContext, this.onClick}); PopupState createState() => PopupState(); } class PopupState extends State { // 声明对象 RenderBox button; RenderBox overlay; RelativeRect position; @override void initState() { super.initState(); // 找到并渲染对象button button = widget.btnContext.findRenderObject(); // 找到并渲染对象overlay overlay = Overlay.of(widget.btnContext).context.findRenderObject(); // 位置设置 position = RelativeRect.fromRect( Rect.fromPoints( button.localToGlobal(Offset.zero, ancestor: overlay), button.localToGlobal(Offset.zero, ancestor: overlay), ), Offset.zero & overlay.size, ); } // item构建 Widget itemBuild(item) { // 字体样式 TextStyle labelStyle = TextStyle(color: Colors.white); return new Expanded( child: new FlatButton( //点击Item onPressed: () { // 如果没接收也返回的花就会报错，所以这里需要判断 if (widget.onClick != null) { Navigator.of(context).pop(); widget.onClick(item); // 事件返回String类型的值 } }, child: new Text(item, style: labelStyle), ), ); } @override Widget build(BuildContext context) { return new Material( type: MaterialType.transparency, // Material类型设置 child: new GestureDetector( child: new Stack( children: [ new Container( // 设置一个容器组件，是整屏幕的。 width: MediaQuery.of(context).size.width, height: MediaQuery.of(context).size.height, color: Colors.transparent, // 它的颜色为透明色 ), new Positioned( child: new Container( width: 200, height: 36, decoration: BoxDecoration( color: Color.fromRGBO(75, 75, 75, 1.0), borderRadius: BorderRadius.all(Radius.circular(4.0)), // 圆角 ), child: new Row(children: ['点赞', '评论'].map(itemBuild).toList()), ), top: position.top, // 顶部位置 right: position.right, // 右边位置 ) ], ), onTap: () => Navigator.of(context).pop(), //点击空白处直接返回 ), ); } } "},"chapter1/theme.html":{"url":"chapter1/theme.html","title":"1.5：App主题色控制及夜间模式","keywords":"","body":"App主题色控制 Theme有两种： 全局Theme和局部Theme。 全局Theme是由应用程序根MaterialApp创建的Theme 。 Theme作用： 可以设置Widget的主题，提高开发效率和速度，保持App主题统一性或某种一致性。 Theme Theme组件可以为material APP定义主题数据（ThemeData）。Material组件库里很多组件都使用了主题数据， 如导航栏颜色、标题字体、Icon样式等。Theme内会使用InheritedWidget来为其子树共享样式数据。 设置主题栗子 全局： /// 全局主题在MaterialApp的theme属性 /// 全局生效 new MaterialApp( title: 'demo', theme: new ThemeData( // 这里就是参数 brightness: Brightness.dark, primaryColor: Colors.lightBlue[800], accentColor: Colors.cyan[600], ), ); 局部： /// 假如我们要给FloatingActionButton设置主题样式 /// 直接写个Theme包裹FloatingActionButton组件 /// 然后设置data，接收类型依然是ThemeData，里面填写我们的参数 /// （如果没有设置局部主题则默认使用全局主题） new Theme( data: new ThemeData( accentColor: Colors.yellow, ), child: new FloatingActionButton( onPressed: () {}, child: new Icon(Icons.add), ), ); 扩展父主题： /// 扩展父主题时无需覆盖所有的主题属性，可以通过使用copyWith方法来实现 new Theme( data: Theme.of(context).copyWith(accentColor: Colors.yellow), child: new FloatingActionButton( onPressed: null, child: new Icon(Icons.add), ), ); Theme.of(context)将查找Widget树并返回树中最近的Theme。如果Widget之上有一个单独的Theme定义， 则返回该值。如果不是，则返回App主题。 判断平台显示指定主题： /// defaultTargetPlatform在foundation包里。 /// /// 我们也可以使用io包里的Platform来进行判断。 /// 那么判断就是 /// theme: Platform.isIOS ? iOSTheme : AndroidTheme, new MaterialApp( theme: defaultTargetPlatform == TargetPlatform.iOS ? iOSTheme : AndroidTheme, title: 'Flutter Theme', home: new MyHomePage(), ); Tips: Flutter的Color中大多数颜色从100到900，增量为100，加上颜色50，数字越小颜色越浅， 数字越大颜色越深。强调色调只有100、200、400和700。 栗子： 推荐站点(Material design)： https://material.io/resources/color, 为你的UI创建共享调色板，并衡量任何颜色组合的可观性【非常实用的工具】。 ThemeData（Color类型属性）： accentColor - 前景色（文本、按钮等） backgroundColor - 与primaryColor对比的颜色(例如 用作进度条的剩余部分)。 bottomAppBarColor - BottomAppBar的默认颜色。 buttonColor - Material中RaisedButtons使用的默认填充色。 canvasColor - MaterialType.canvas Material的默认颜色。 cardColor - Material被用作Card时的颜色。 dialogBackgroundColor - Dialog元素的背景色。 disabledColor - 用于Widget无效的颜色，无论任何状态。例如禁用复选框。 dividerColor - Dividers和PopupMenuDividers的颜色，也用于ListTiles中间，和DataTables的每行中间. errorColor - 用于输入验证错误的颜色，例如在TextField中。 highlightColor - 用于类似墨水喷溅动画或指示菜单被选中的高亮颜色。 hintColor - 用于提示文本或占位符文本的颜色，例如在TextField中。 indicatorColor - TabBar中选项选中的指示器颜色。 primaryColor - App主要部分的背景色（ToolBar,TabBar等）。 primaryColorDark - primaryColor的较暗版本。 primaryColorLight - primaryColor的较亮版本。 scaffoldBackgroundColor - 作为Scaffold基础的Material默认颜色，典型Material应用或应用内页面的背景颜色。 secondaryHeaderColor - 有选定行时PaginatedDataTable标题的颜色。 selectedRowColor - 选中行时的高亮颜色。 splashColor - 墨水喷溅的颜色。 textSelectionColor - 文本字段中选中文本的颜色，例如TextField。 textSelectionHandleColor - 用于调整当前文本的哪个部分的句柄颜色。 toggleableActiveColor - 用于突出显示切换Widget（如Switch，Radio和Checkbox）的活动状态的颜色。 unselectedWidgetColor - 用于Widget处于非活动（但已启用）状态的颜色。 例如，未选中的复选框。 通常与accentColor形成对比。 focusColor - 焦点获取时的颜色，例如，一些按钮焦点、输入框焦点。 hoverColor - 点击之后徘徊中的颜色，例如，按钮长按，按住之后的颜色。 cursorColor - 输入框光标颜色。 ThemeData（Theme相关类型属性）： accentIconTheme - IconThemeData类型，与突出颜色对照的图片主题。 accentTextTheme - TextTheme类型，与突出颜色对照的文本主题。 chipTheme - ChipThemeData类型，用于渲染Chip的颜色和样式。 buttonTheme - ButtonThemeData类型，定义了按钮等控件的默认配置，像RaisedButton和FlatButton。 primaryIconTheme - IconThemeData类型，一个与主色对比的图片主题。 primaryTextTheme - TextThemeData类型，一个与主色对比的文本主题。 iconTheme - IconThemeData类型，与卡片和画布颜色形成对比的图标主题。 inputDecorationTheme - InputDecorationTheme类型，InputDecorator，TextField和TextFormField的默认InputDecoration值基于此主题。 sliderTheme - SliderThemeData类型，用于渲染Slider的颜色和形状。 textTheme - TextTheme类型，与卡片和画布对比的文本颜色。 toggleButtonsTheme - ToggleButtonsThemeData类型，​Flutter 1.9 全新组件 ToggleButtons 的主题。 tabBarTheme - TabBarTheme类型，TabBar的主题样式。 tooltipTheme - TooltipThemeData类型，tooltip提示的主题样式。 cardTheme - CardTheme类型，卡片的主题样式。 pageTransitionsTheme - PageTransitionsTheme类型，页面转场主题样式。 appBarTheme - AppBarTheme类型，AppBar主题样式。 bottomAppBarTheme - BottomAppBarTheme类型，底部导航主题样式。 dialogTheme - DialogTheme类型，对话框主题样式。 floatingActionButtonTheme - FloatingActionButtonThemeData类型，FloatingActionButton的主题样式，也就是Scaffold属性的那个。 cupertinoOverrideTheme - CupertinoThemeData类型，cupertino覆盖的主题样式。 snackBarTheme - SnackBarThemeData类型，弹出的snackBar的主题样式。 bottomSheetTheme - BottomSheetThemeData类型，底部滑出对话框的主题样式。 popupMenuTheme - PopupMenuThemeData类型，弹出菜单对话框的主题样式。 bannerTheme - MaterialBannerThemeData类型，Material材质的Banner主题样式。 dividerTheme - DividerThemeData类型，Divider组件的主题样式，也就是那个横向线条组件。 ThemeData（其他类型属性）： accentColorBrightness - Brightness类型，accentColor的亮度。 用于确定放置在突出颜色顶部的文本和图标的颜色（例如FloatingButton上的图标）。 brightness - Brightness类型，应用程序整体主题的亮度。 由按钮等Widget使用，以确定在不使用主色或强调色时要选择的颜色。 platform - TargetPlatform类型，Widget需要适配的目标类型。 splashFactory - InteractiveInkFeatureFactory类型，定义InkWall和InkResponse生成的墨水喷溅的外观。 primaryColorBrightness - Brightness类型，primaryColor的亮度。 fontFamily - String类型，字体样式。 applyElevationOverlayColor bool类型，是否应用elevation覆盖颜色。 materialTapTargetSize - MaterialTapTargetSize类型，Chip等组件的尺寸主题设置，如：设置为MaterialTapTargetSize.shrinkWrap时，clip距顶部距离为0；设置为MaterialTapTargetSize.padded时距顶部有一个距离 colorScheme - ColorScheme类型，scheme组颜色，一组13种颜色，可用于配置大多数组件的颜色属性。 typography - Typography类型,用于配置TextTheme、primaryTextTheme和accentTextTheme的颜色和几何文本主题值。 适配夜间模式 实现效果： 分析： 这次是使用局部的实现，哪个页面需要同步就加个Theme就行了，全局也是类似的实现方式，主体代码不到100行。 代码： 首先写个配置类，主要配置主题的是否为黑夜模式和主题样式： class Config { static bool dark = true; // 是否为黑夜模式 static ThemeData themeData = new ThemeData.dark(); // 主题为暗色 } 然后我们正常的执行代码： import 'package:flutter/material.dart'; import 'global_config.dart'; void main() => runApp(new MyApp()); class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return new MaterialApp(title: \"Flutter高级进阶\", home: new MyScaffold()); } } class MyScaffold extends StatefulWidget { @override _MyScaffoldState createState() => _MyScaffoldState(); } class _MyScaffoldState extends State { /* * 主题改变 * */ changeTheme() { if (Config.dark) { Config.themeData = new ThemeData( primaryColor: Colors.white, scaffoldBackgroundColor: new Color(0xFFEBEBEB), ); Config.dark = false; } else { Config.themeData = new ThemeData.dark(); Config.dark = true; } setState(() {}); } Widget body(context) { return new ListView( children: [ new Container( width: MediaQuery.of(context).size.width / 4, // 整宽除4 child: new GestureDetector( onTap: () => changeTheme(), // 触发更换主题的事件 child: new Column( children: [ new FlutterLogo( size: 150.0, style: FlutterLogoStyle.horizontal, duration: Duration(milliseconds: 100), textColor: Theme.of(context).colorScheme.background, // 从上下文拿到背景 ), new Text( // 如果为黑夜模式则按钮文字为白天模式，否则文字显示为黑夜模式 '点击Logo更换${Config.dark ? \"白天模式\" : \"黑夜模式\"}', style: new TextStyle(fontSize: 25.0), ), ], ), ), ), new MaterialButton( // 跳转按钮 onPressed: () { Navigator.of(context).push(new MaterialPageRoute( builder: (context) => new NewPage('Flutter高级进阶页面二'))); }, child: new Text('跳转到新页面'), ), ], ); } @override Widget build(BuildContext context) { return new Theme( // 主题组件，可设置局部的主题样式 data: Config.themeData, // 设置为配置的主题数据 child: new Scaffold( appBar: new AppBar(elevation: 0), body: body(context), // 身体页面body ), ); } } 再把NewPage测试页面写上： class NewPage extends StatefulWidget { final String title; // 接收的标题 NewPage(this.title); @override _NewPageState createState() => new _NewPageState(); // 创建有状态页面 } class _NewPageState extends State { @override Widget build(BuildContext context) { return new Theme( child: new Scaffold( // title就是我们的标题 appBar: new AppBar(title: new Text('页面：${widget.title}'), elevation: 0), body: new Center( child: new Text( '这是${widget.title}', style: TextStyle(fontSize: 30.0), ), ), ), data: Config.themeData, // 设置为配置的主题数据 ); } } 直接复制到自己的项目内即可运行。 "},"chapter1/upgrade.html":{"url":"chapter1/upgrade.html","title":"1.6：App内更新并自动打开安装","keywords":"","body":"App内更新并自动打开安装 实现效果： 需要的小火箭图片： 需求： 进入App进行一次检测，如有新版本则弹出更新对话框； 如后台设置强制更新则无任何取消更新进入App的可能性； 显示更新内容和版本信息Log等； 如用户点击更新按钮则开始下载并展示下载进度； 下载安装包完毕后直接打开安装包进入安装页面； 分析： 需要字段：是否强制更新、更新内容、安装包URL； 使用WillPopScope拦截返回事件； 因为需要显示下载进度则dialog内需要放有状态类； 如果不需要强制更新则显示出❌，允许用户取消更新； 第三方库： 名称 作用 package_info app版本和平台信息 url_launcher 打开AppStore更新IOS版安装包 open_file 打开安装包进入安装页面 path_provider 配置安装包下载路径 dio 接口最新版本数据、下载安装包 开干 1.首先把需要的库配置一下,在我们的pubspec.yaml文件 url_launcher: any package_info: any open_file: any path_provider: any dio: any 2.定义模拟的数据 Map mockData = { 'isForceUpdate': false, // 是否强制更新 'content': '这是更新的内容', 'url': 'http://www.flutterj.com/test.apk', // 安装包的链接 }; 3.写对话框 Future updateAlert(BuildContext context, Map data) async { bool isForceUpdate = data['isForceUpdate']; // 从数据拿到是否强制更新字段 new Future.delayed(Duration(seconds: 2)).then((value) { showDialog( // 显示对话框 context: context, barrierDismissible: false, // 点击空白区域不结束对话框 builder: (_) => new WillPopScope( // 拦截返回键 child: new UpgradeDialog(data, isForceUpdate, updateUrl: data['url']), // 有状态类对话框 onWillPop: () { return; // 检测到返回键直接返回 }, ), ); }); } 然后我们的有状态对话框类： class UpgradeDialog extends StatefulWidget { final Map data; // 数据 final bool isForceUpdate; // 是否强制更新 final String updateUrl; // 更新的url（安装包下载地址） UpgradeDialog(this.data, this.isForceUpdate, {this.updateUrl}); @override _UpgradeDialogState createState() => _UpgradeDialogState(); } class _UpgradeDialogState extends State { int _downloadProgress = 0; // 进度初始化为0 CancelToken token; UploadingFlag uploadingFlag = UploadingFlag.idle; @override void initState() { super.initState(); token = new CancelToken(); // token初始化 } @override Widget build(BuildContext context) { String info = widget.data['content']; // 更新内容 return new Center( // 剧中组件 child: new Material( type: MaterialType.transparency, textStyle: new TextStyle(color: const Color(0xFF212121)), child: new Container( width: MediaQuery.of(context).size.width * 0.8, // 宽度是整宽的百分之80 decoration: BoxDecoration( color: Colors.white, // 背景白色 borderRadius: BorderRadius.all(Radius.circular(4.0)), // 圆角 ), child: new Wrap( children: [ new SizedBox(height: 10.0, width: 10.0), new Align( alignment: Alignment.topRight, child: widget.isForceUpdate ? new Container() : new InkWell( // 不强制更新才显示这个 child: new Padding( padding: EdgeInsets.only( top: 5.0, right: 15.0, bottom: 5.0, left: 5.0, ), child: new Icon( Icons.clear, color: Colors.black, ), ), onTap: () => Navigator.of(context).pop(), ), ), new Center( child: new Image.asset('img/upgrade1.png', width: 121.5, fit: BoxFit.cover), ), new Container( height: 30.0, width: double.infinity, alignment: Alignment.center, child: new Text('升级到最新版本', style: new TextStyle( color: const Color(0xff343243), fontSize: 17.0, fontWeight: FontWeight.bold)), ), new Container( width: double.infinity, alignment: Alignment.center, child: new Padding( padding: EdgeInsets.symmetric(horizontal: 40.0, vertical: 15.0), child: new Text('$info', style: new TextStyle(color: Color(0xff7A7A7A)))), ), getLoadingWidget(), new Container( height: 80.0, width: double.infinity, padding: EdgeInsets.symmetric(horizontal: 10.0, vertical: 18.0), margin: EdgeInsets.only(bottom: 10.0), decoration: BoxDecoration( borderRadius: new BorderRadius.only( bottomLeft: Radius.circular(12.0), bottomRight: Radius.circular(12.0)), ), child: new MaterialButton( child: new Text('立即升级'), onPressed: () => upgradeHandle(), ), ), ], ), ), ), ); } /* * Android更新处理 * */ void _androidUpdate() async { final apkPath = await FileUtil.getInstance().getSavePath(\"/Download/\"); try { await Dio().download( widget.updateUrl, apkPath + \"test.apk\", cancelToken: token, onReceiveProgress: (int count, int total) { if (mounted) { setState(() { _downloadProgress = ((count / total) * 100).toInt(); if (_downloadProgress == 100) { if (mounted) { setState(() { uploadingFlag = UploadingFlag.uploaded; }); } debugPrint(\"读取的目录:$apkPath\"); try { OpenFile.open(apkPath + \"test.apk\"); } catch (e) {} Navigator.of(context).pop(); } }); } }, options: Options(sendTimeout: 15 * 1000, receiveTimeout: 360 * 1000), ); } catch (e) { if (mounted) { setState(() { uploadingFlag = UploadingFlag.uploadingFailed; }); } } } /* * 进度显示的组件 * */ Widget getLoadingWidget() { if (_downloadProgress != 0 && uploadingFlag == UploadingFlag.uploading) { return Container( padding: EdgeInsets.symmetric(vertical: 5.0), width: double.infinity, height: 40, alignment: Alignment.center, child: LinearProgressIndicator( valueColor: AlwaysStoppedAnimation(Theme.of(context).primaryColor), backgroundColor: Colors.grey[300], value: _downloadProgress / 100, ), ); } /* * 如果是在进行中并且进度为0则显示 * */ if (uploadingFlag == UploadingFlag.uploading && _downloadProgress == 0) { return Container( alignment: Alignment.center, height: 40, child: Row( mainAxisAlignment: MainAxisAlignment.center, crossAxisAlignment: CrossAxisAlignment.center, children: [ CircularProgressIndicator( valueColor: AlwaysStoppedAnimation(mainTextColor)), SizedBox(width: 5), Material( child: Text( '等待', style: TextStyle(color: mainTextColor), ), color: Colors.transparent, ) ], ), ); } /* * 如果下载失败则显示 * */ if (uploadingFlag == UploadingFlag.uploadingFailed) { return Container( alignment: Alignment.center, height: 40, child: Row( mainAxisAlignment: MainAxisAlignment.center, crossAxisAlignment: CrossAxisAlignment.center, children: [ Icon(Icons.clear, color: Colors.redAccent), SizedBox(width: 5), Material( child: Text( '下载超时', style: TextStyle(color: mainTextColor), ), color: Colors.transparent, ) ], ), ); } return Container(); } /* * IOS更新处理，直接打开AppStore链接 * */ void _iosUpdate() { launch(widget.updateUrl); } /* * 更新处理事件 * */ upgradeHandle() { if (uploadingFlag == UploadingFlag.uploading) return; uploadingFlag = UploadingFlag.uploading; // 必须保证当前状态安全，才能进行状态刷新 if (mounted) setState(() {}); // 进行平台判断 if (Platform.isAndroid) { _androidUpdate(); } else if (Platform.isIOS) { _iosUpdate(); } } ///跳转本地浏览器 launchURL(String url) async { if (await canLaunch(url)) { await launch(url); } else { throw 'Could not launch $url'; } } @override void dispose() { if (!token.isCancelled) token?.cancel(); super.dispose(); debugPrint(\"升级销毁\"); } } 然后我们需要一个文件路径工具类和一个类型枚举： enum UploadingFlag { uploading, idle, uploaded, uploadingFailed } // 文件工具类 class FileUtil { static FileUtil _instance; static FileUtil getInstance() { if (_instance == null) { _instance = FileUtil._internal(); } return _instance; } FileUtil._internal(); /* * 保存路径 * */ Future getSavePath(String endPath) async { Directory tempDir = await getApplicationDocumentsDirectory(); String path = tempDir.path + endPath; Directory directory = Directory(path); if (!directory.existsSync()) { directory.createSync(recursive: true); } return path; } } 然后我们就可以直接在初始化的时候调用就行了： class MyHomePage extends StatefulWidget { @override _MyHomePageState createState() => _MyHomePageState(); } class _MyHomePageState extends State { @override void initState() { super.initState(); Map mockData = { 'isForceUpdate': false,// 是否强制更新 'content': '这是更新的内容', 'url': 'http://www.flutterj.com/test.apk',// 安装包的链接 }; updateAlert(context, mockData); } @override Widget build(BuildContext context) { return new Scaffold( appBar: new AppBar(title: new Text('Flutter高级进阶')), ); } } 完整代码： main.dart import 'package:flutter/material.dart'; import 'package:oc_project/dialog.dart'; void main() => runApp(MyApp()); class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return new MaterialApp( title: 'Flutter高级进阶', home: new MyHomePage(), ); } } class MyHomePage extends StatefulWidget { @override _MyHomePageState createState() => _MyHomePageState(); } class _MyHomePageState extends State { @override void initState() { super.initState(); Map mockData = { 'isForceUpdate': false,// 是否强制更新 'content': '这是更新的内容', 'url': 'http://www.flutterj.com/test.apk',// 安装包的链接 }; updateAlert(context, mockData); } @override Widget build(BuildContext context) { return new Scaffold( appBar: new AppBar(title: new Text('Flutter高级进阶')), ); } } dialog.dart import 'dart:io'; import 'package:dio/dio.dart'; import 'package:flutter/cupertino.dart'; import 'package:flutter/material.dart'; import 'package:open_file/open_file.dart'; import 'package:url_launcher/url_launcher.dart'; import 'package:path_provider/path_provider.dart'; const mainTextColor = Color.fromRGBO(115, 115, 115, 1.0); Future updateAlert(BuildContext context, Map data) async { bool isForceUpdate = data['isForceUpdate']; // 从数据拿到是否强制更新字段 new Future.delayed(Duration(seconds: 2)).then((value) { showDialog( // 显示对话框 context: context, barrierDismissible: false, // 点击空白区域不结束对话框 builder: (_) => new WillPopScope( // 拦截返回键 child: new UpgradeDialog(data, isForceUpdate, updateUrl: data['url']), // 有状态类对话框 onWillPop: () { return; // 检测到返回键直接返回 }, ), ); }); } class UpgradeDialog extends StatefulWidget { final Map data; // 数据 final bool isForceUpdate; // 是否强制更新 final String updateUrl; // 更新的url（安装包下载地址） UpgradeDialog(this.data, this.isForceUpdate, {this.updateUrl}); @override _UpgradeDialogState createState() => _UpgradeDialogState(); } class _UpgradeDialogState extends State { int _downloadProgress = 0; // 进度初始化为0 CancelToken token; UploadingFlag uploadingFlag = UploadingFlag.idle; @override void initState() { super.initState(); token = new CancelToken(); // token初始化 } @override Widget build(BuildContext context) { String info = widget.data['content']; // 更新内容 return new Center( // 剧中组件 child: new Material( type: MaterialType.transparency, textStyle: new TextStyle(color: const Color(0xFF212121)), child: new Container( width: MediaQuery.of(context).size.width * 0.8, // 宽度是整宽的百分之80 decoration: BoxDecoration( color: Colors.white, // 背景白色 borderRadius: BorderRadius.all(Radius.circular(4.0)), // 圆角 ), child: new Wrap( children: [ new SizedBox(height: 10.0, width: 10.0), new Align( alignment: Alignment.topRight, child: widget.isForceUpdate ? new Container() : new InkWell( // 不强制更新才显示这个 child: new Padding( padding: EdgeInsets.only( top: 5.0, right: 15.0, bottom: 5.0, left: 5.0, ), child: new Icon( Icons.clear, color: Colors.black, ), ), onTap: () => Navigator.of(context).pop(), ), ), new Center( child: new Image.asset('img/upgrade1.png', width: 121.5, fit: BoxFit.cover), ), new Container( height: 30.0, width: double.infinity, alignment: Alignment.center, child: new Text('升级到最新版本', style: new TextStyle( color: const Color(0xff343243), fontSize: 17.0, fontWeight: FontWeight.bold)), ), new Container( width: double.infinity, alignment: Alignment.center, child: new Padding( padding: EdgeInsets.symmetric(horizontal: 40.0, vertical: 15.0), child: new Text('$info', style: new TextStyle(color: Color(0xff7A7A7A)))), ), getLoadingWidget(), new Container( height: 80.0, width: double.infinity, padding: EdgeInsets.symmetric(horizontal: 10.0, vertical: 18.0), margin: EdgeInsets.only(bottom: 10.0), decoration: BoxDecoration( borderRadius: new BorderRadius.only( bottomLeft: Radius.circular(12.0), bottomRight: Radius.circular(12.0)), ), child: new MaterialButton( child: new Text('立即升级'), onPressed: () => upgradeHandle(), ), ), ], ), ), ), ); } /* * Android更新处理 * */ void _androidUpdate() async { final apkPath = await FileUtil.getInstance().getSavePath(\"/Download/\"); try { await Dio().download( widget.updateUrl, apkPath + \"test.apk\", cancelToken: token, onReceiveProgress: (int count, int total) { if (mounted) { setState(() { _downloadProgress = ((count / total) * 100).toInt(); if (_downloadProgress == 100) { if (mounted) { setState(() { uploadingFlag = UploadingFlag.uploaded; }); } debugPrint(\"读取的目录:$apkPath\"); try { OpenFile.open(apkPath + \"test.apk\"); } catch (e) {} Navigator.of(context).pop(); } }); } }, options: Options(sendTimeout: 15 * 1000, receiveTimeout: 360 * 1000), ); } catch (e) { if (mounted) { setState(() { uploadingFlag = UploadingFlag.uploadingFailed; }); } } } /* * 进度显示的组件 * */ Widget getLoadingWidget() { if (_downloadProgress != 0 && uploadingFlag == UploadingFlag.uploading) { return Container( padding: EdgeInsets.symmetric(vertical: 5.0), width: double.infinity, height: 40, alignment: Alignment.center, child: LinearProgressIndicator( valueColor: AlwaysStoppedAnimation(Theme.of(context).primaryColor), backgroundColor: Colors.grey[300], value: _downloadProgress / 100, ), ); } /* * 如果是在进行中并且进度为0则显示 * */ if (uploadingFlag == UploadingFlag.uploading && _downloadProgress == 0) { return Container( alignment: Alignment.center, height: 40, child: Row( mainAxisAlignment: MainAxisAlignment.center, crossAxisAlignment: CrossAxisAlignment.center, children: [ CircularProgressIndicator( valueColor: AlwaysStoppedAnimation(mainTextColor)), SizedBox(width: 5), Material( child: Text( '等待', style: TextStyle(color: mainTextColor), ), color: Colors.transparent, ) ], ), ); } /* * 如果下载失败则显示 * */ if (uploadingFlag == UploadingFlag.uploadingFailed) { return Container( alignment: Alignment.center, height: 40, child: Row( mainAxisAlignment: MainAxisAlignment.center, crossAxisAlignment: CrossAxisAlignment.center, children: [ Icon(Icons.clear, color: Colors.redAccent), SizedBox(width: 5), Material( child: Text( '下载超时', style: TextStyle(color: mainTextColor), ), color: Colors.transparent, ) ], ), ); } return Container(); } /* * IOS更新处理，直接打开AppStore链接 * */ void _iosUpdate() { launch(widget.updateUrl); } /* * 更新处理事件 * */ upgradeHandle() { if (uploadingFlag == UploadingFlag.uploading) return; uploadingFlag = UploadingFlag.uploading; // 必须保证当前状态安全，才能进行状态刷新 if (mounted) setState(() {}); // 进行平台判断 if (Platform.isAndroid) { _androidUpdate(); } else if (Platform.isIOS) { _iosUpdate(); } } ///跳转本地浏览器 launchURL(String url) async { if (await canLaunch(url)) { await launch(url); } else { throw 'Could not launch $url'; } } @override void dispose() { if (!token.isCancelled) token?.cancel(); super.dispose(); debugPrint(\"升级销毁\"); } } enum UploadingFlag { uploading, idle, uploaded, uploadingFailed } // 文件工具类 class FileUtil { static FileUtil _instance; static FileUtil getInstance() { if (_instance == null) { _instance = FileUtil._internal(); } return _instance; } FileUtil._internal(); /* * 保存路径 * */ Future getSavePath(String endPath) async { Directory tempDir = await getApplicationDocumentsDirectory(); String path = tempDir.path + endPath; Directory directory = Directory(path); if (!directory.existsSync()) { directory.createSync(recursive: true); } return path; } } "},"chapter2/":{"url":"chapter2/","title":"第2章：优化篇","keywords":"","body":"本章目录 局部刷新优化性能 路由管理控制 开发路由管理框架 "},"chapter2/partial_refresh.html":{"url":"chapter2/partial_refresh.html","title":"2.1：局部刷新优化性能","keywords":"","body":"局部刷新优化性能 Flutter状态类： StatelessWidget：无状态类，没有状态更新，界面一经创建无法更改； StatefulWidget：有状态类，当状态改变，调用setState()方法会触发StatefulWidget的UI状态更新，自定义继承StatefulWidget的子类须重写createState()方法。 案例： 当我们调用有状态类的setState方法时会遍历每一个子Widget的State.build刷新状态， 这将是一笔很大的性能开销，所以我们需要使用局部刷新来进行优化。 普通刷新方式 class TestRoute extends StatefulWidget { @override _TestRouteState createState() => _TestRouteState(); } class _TestRouteState extends State { int count = 0; @override Widget build(BuildContext context) { return new FlatButton( onPressed: () { setState(() => count++); }, child: new Text('$count'), ); } } 一个有状态类定义一个变量然后按钮的事件调用setState让这个变量进行刷新， 使用GlobalKey局部刷新方式 我们还是用上面的例子，只是通过GlobalKey的方式只刷新局部的Text， class TestRoute extends StatefulWidget { @override _TestRouteState createState() => _TestRouteState(); } class _TestRouteState extends State { int count = 0; GlobalKey textKey = GlobalKey(); @override Widget build(BuildContext context) { return new Column( mainAxisAlignment: MainAxisAlignment.center, children: [ new TextWidget(textKey), //需要更新的Text new FlatButton( onPressed: () { count++; // 这里我们只给他值变动，状态刷新交给下面的Key事件 textKey.currentState.onPressed(count); }, child: new Text('按钮 $count'), ), ], ); } } // 封装的文本组件Widget class TextWidget extends StatefulWidget { final Key key; // 接收一个Key TextWidget(this.key); @override State createState() => TextWidgetState(); } class TextWidgetState extends State { String _text = \"0\"; @override Widget build(BuildContext context) { return new Text(_text); } void onPressed(int count) { setState(() => _text = count.toString()); } } 效果： 可以明显的看到按钮的count并无变动，但需要更新的文本组件更新了值，已经完美实现了局部刷新。 实现原理： textKey是一个GlobalKey类型的Key范型为TextWidgetState（封装的文本&&有状态类）， 所以这个Key可以通过currentState方法调用到类里面的onPressed方法， 而onPressed方法刚好有调用setState来刷新局部状态。 "},"chapter2/route.html":{"url":"chapter2/route.html","title":"2.2：路由管理控制","keywords":"","body":"路由管理控制 路由是一个应用程序抽象的屏幕或页面； 路由管理就是管理页面之间如何跳转； 路由入栈指打开一个新页面； 路由出栈指一个页面关闭操作； 路由管理指如何来管理路由栈； Navigator是一个管理路由的widget； NavigatorKey是一个管理路由的Key； 看完本文你将学会路由的使用、管理好一个路由、路由传参、路由带参返回、 路由记录、返回到指定路由、路由动画， 然后使用pop操作来进行回退到某个路由； Navigator 方法 作用 pushNamed 按路由名字路由入栈 pushReplacementNamed 按路由名字替换当前路由栈 popAndPushNamed 将当前路线从导航器中弹出，并在其中推入已命名的路由位置 pushNamedAndRemoveUntil 按路由名称将具有给定名称的路由推入导航器，然后删除所有 push 直接路由入栈 pushReplacement 替换当前路由栈 pushAndRemoveUntil 将具有给定名称的路由推入导航器，然后删除所有 replace 用新路由替换导航器上的路由 replaceRouteBelow 用新路由替换导航器上的路由。 路由是替换为给定anchorRoute下面的那个 canPop 导航器是否可以弹出。 maybePop 导航器是否可以弹出，可以的话弹出 pop 弹出路由 popUntil 一直弹出直到指定路由 removeRoute 删除指定路由 removeRouteBelow 立即从导航器中删除一条路由，然后[Route.dispose]的要替换的路线是给定的“ anchorRoute”下方的路线。 开始上手 我们创建个普通路由跳转，跳转到原页面，但是标题的数量会+1，让我们知道当前是push到的第几个页面； 路由跳转传参示例： import 'package:flutter/material.dart'; void main() => runApp(MyApp()); class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return new MaterialApp( title: 'Flutter高级进阶', home: new MyHomePage(), ); } } class MyHomePage extends StatefulWidget { // 接收的num参数 final int num; // MyHomePage不写参数则默认为1 MyHomePage({this.num = 1}); @override _MyHomePageState createState() => _MyHomePageState(); } class _MyHomePageState extends State { @override Widget build(BuildContext context) { return new Scaffold( // 显示接收的num参数 appBar: new AppBar(title: new Text('Flutter高级进阶${widget.num}')), // 按钮点击执行跳转方法 body: new FlatButton(child: new Text(\"push\"), onPressed: () => push()), ); } /* * 路由跳转方法 * */ push() { // 拿到传过来的num然后+1 int num = widget.num + 1; //导航到新路由 Navigator.push( context, MaterialPageRoute( // num传给下一级 builder: (context) => MyHomePage(num: num)), ); } } 效果图： 错误示例： class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return new MaterialApp( title: 'Flutter高级进阶', home: new Scaffold( appBar: new AppBar(), body: new FlatButton(child: new Text(\"push\"), onPressed: () => push(context)), ), ); } /* * 路由跳转方法 * */ push(context) { //导航到新路由 Navigator.push( context, MaterialPageRoute( // MyHomePage不写参数则默认为1 builder: (context) => MyHomePage()), ); } } 报错信息： I/flutter (21935): ══╡ EXCEPTION CAUGHT BY GESTURE ╞═══════════════════════════════════════════════════════════════════ I/flutter (21935): The following assertion was thrown while handling a gesture: I/flutter (21935): Navigator operation requested with a context that does not include a Navigator. I/flutter (21935): The context used to push or pop routes from the Navigator must be that of a widget that is a I/flutter (21935): descendant of a Navigator widget. I/flutter (21935): I/flutter (21935): When the exception was thrown, this was the stack: I/flutter (21935): #0 Navigator.of. (package:flutter/src/widgets/navigator.dart:1475:9) I/flutter (21935): #1 Navigator.of (package:flutter/src/widgets/navigator.dart:1482:6) I/flutter (21935): #2 Navigator.push (package:flutter/src/widgets/navigator.dart:1107:22) I/flutter (21935): #3 MyApp.push (package:oc_project/main.dart:18:15) I/flutter (21935): #4 MyApp.build. (package:oc_project/main.dart:12:72) I/flutter (21935): #5 _InkResponseState._handleTap (package:flutter/src/material/ink_well.dart:654:14) I/flutter (21935): #6 _InkResponseState.build. (package:flutter/src/material/ink_well.dart:729:32) I/flutter (21935): #7 GestureRecognizer.invokeCallback (package:flutter/src/gestures/recognizer.dart:182:24) I/flutter (21935): #8 TapGestureRecognizer._checkUp (package:flutter/src/gestures/tap.dart:365:11) I/flutter (21935): #9 TapGestureRecognizer.handlePrimaryPointer (package:flutter/src/gestures/tap.dart:275:7) I/flutter (21935): #10 PrimaryPointerGestureRecognizer.handleEvent (package:flutter/src/gestures/recognizer.dart:455:9) I/flutter (21935): #11 PointerRouter._dispatch (package:flutter/src/gestures/pointer_router.dart:75:13) I/flutter (21935): #12 PointerRouter.route (package:flutter/src/gestures/pointer_router.dart:102:11) I/flutter (21935): #13 GestureBinding.handleEvent (package:flutter/src/gestures/binding.dart:218:19) I/flutter (21935): #14 GestureBinding.dispatchEvent (package:flutter/src/gestures/binding.dart:198:22) I/flutter (21935): #15 GestureBinding._handlePointerEvent (package:flutter/src/gestures/binding.dart:156:7) I/flutter (21935): #16 GestureBinding._flushPointerEventQueue (package:flutter/src/gestures/binding.dart:102:7) I/flutter (21935): #17 GestureBinding._handlePointerDataPacket (package:flutter/src/gestures/binding.dart:86:7) I/flutter (21935): #21 _invoke1 (dart:ui/hooks.dart:263:10) I/flutter (21935): #22 _dispatchPointerDataPacket (dart:ui/hooks.dart:172:5) I/flutter (21935): (elided 3 frames from package dart:async) I/flutter (21935): I/flutter (21935): Handler: \"onTap\" I/flutter (21935): Recognizer: I/flutter (21935): TapGestureRecognizer#72729 这个报错是因为用的这个上下文是MaterialApp的，这个上下文不包含Navigator导航器操作， 所以我们应该把home的那部分抽出来放另一个类； 路由传值并返回值 路由传参在上面那个例子已经有了，num就是我们的参数，然后显示在标题上就是使用了。 这节教大家路由传值并返回值，创建个NewPage，接收个文本值text，然后显示在新页面，新页面给个返回按钮， 点击返回按钮返回并带回一串值回去。 NewPage： class NewPage extends StatelessWidget { final String text; NewPage({ @required this.text, // 接收一个text参数 }); @override Widget build(BuildContext context) { return new Scaffold( appBar: new AppBar(title: new Text(\"新页面：$text\")), body: new RaisedButton( onPressed: () => Navigator.pop(context, \"我是返回值\"), child: new Text(\"返回\"), ), ); } } 然后之前写好的push方法改下，用then接收： /* * 路由跳转方法 * */ push() { //导航到新路由 Navigator.push( context, MaterialPageRoute( // 拿到传过来的num然后++传给下一级 builder: (context) => NewPage(text: '参数'), ), ).then((value) { if (value != null) print('接收到的参数：$value'); }); } 这样我们就能push到新页面然后点击返回按钮就能把参数返回到push到它的那个方法，然后在then打印出来了： I/flutter (21935): 接收到的参数：我是返回值 直接点击左上角那个返回值会为空，这样打印出来的就是： I/flutter (21935): 接收到的参数：null 所以我们做了一个判断，不为空才执行打印，如果为空就不做任何操作； 路由命名 我们想执行跟name有关的Navigator方法就必须先给路由命名，比如pushNamed方法, 注册路由在MaterialApp的routes属性，它的定义为： final Map routes; 注册示例 class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return new MaterialApp( title: 'Flutter高级进阶', routes: { \"newPage\": (context) => new NewPage(text: '注册路由名的新页面'), }, home: new MyHomePage(), ); } } 这样我们的newPage就注册好了，然后试试pushNamed方法： /* * 路由跳转方法 * */ push() { Navigator.pushNamed(context, \"newPage\").then((value) { if (value != null) print('接收到的参数：$value'); }); } 效果图： 返回到指定路由 这节我们使用popUntil方法返回到我们想要返回到的某个路由，首先再注册两个路由名： @override Widget build(BuildContext context) { return new MaterialApp( title: 'Flutter高级进阶', routes: { // 新页面路由名 \"newPage\": (context) => new NewPage(text: '注册路由名的新页面'), // 第二个路由名 \"towPage\": (context) => new TowPage(), // 首页路由名 \"/\": (context) => new MyHomePage(), }, // home: new MyHomePage(), 这个必须注释，因为我们注册了根路由名：\"/\"，否则报错 ); } TowPage: class TowPage extends StatelessWidget { @override Widget build(BuildContext context) { return Scaffold( appBar: new AppBar(title: new Text('页面二')), body: new RaisedButton( onPressed: () => Navigator.popUntil(context, ModalRoute.withName('/')), child: new Text(\"返回到首页\"), ), ); } } 然后NewPage把返回改成push到第二个页面： class NewPage extends StatelessWidget { final String text; NewPage({ @required this.text, // 接收一个text参数 }); @override Widget build(BuildContext context) { return new Scaffold( appBar: new AppBar(title: new Text(\"新页面：$text\")), body: new RaisedButton( onPressed: () => Navigator.pushNamed(context, \"towPage\"), child: new Text(\"到第二个页面\"), ), ); } } 效果图： 这样就实现了到第二个页面的时候点击回到首页按钮就直接返回到首页了。 路由记录 我们每次跳转一个新路由然后想返回到之前跳转过的某个路由难道每个都要注册路由名吗？那样的话太麻烦了， 这节就教大家路由记录，只要我们跳转过某个路由就记录起来， 然后最后面的路由想返回到前面的三个中的某个都不需要配置名字了。 配置： /* * 路由跳转方法 * */ push() { Navigator.push( context, MaterialPageRoute( builder: (context) => MyHomePage(), settings: new RouteSettings( name: MyHomePage().toStringShort(), // 设置的路由名 isInitialRoute: false, // 是否初始路由 ), ), ); } 这样我们就把我们要跳转到的MyHomePage跳转了，同时还记录了路由名字； 使用： class TowPage extends StatelessWidget { @override Widget build(BuildContext context) { return Scaffold( appBar: new AppBar(title: new Text('页面二')), body: new RaisedButton( onPressed: () => Navigator.popUntil( context, // 使用记录好的路由名字 ModalRoute.withName(MyHomePage().toStringShort()), ), child: new Text(\"返回到MyHomePage\"), ), ); } } 这样我们就可以完美的返回到MyHomePage页面了，使用起来非常方便。 路由动画理论 路由动画就是我们跳转到下一个路由栈的时候所产生的过度动画，官方提供了两个动画： MaterialPageRoute、CupertinoPageRoute； 解释： MaterialPageRoute：存在于：import 'package:flutter/material.dart';包； CupertinoPageRoute：存在于：import 'package:flutter/cupertino.dart';包； 使用： 直接把我们用来push的MaterialPageRoute更改为：CupertinoPageRoute即可查看动画效果； 自定义路由动画 首先编写好一个路由动画，路由动画必须继承至PageRouteBuilder： /* * 渐变动画 * */ class FadeRoute extends PageRouteBuilder { // 传过来的页面page final Widget page; // 构造 FadeRoute({this.page}) : super( pageBuilder: ( BuildContext context, Animation animation, Animation secondaryAnimation, ) => page, transitionsBuilder: ( BuildContext context, Animation animation, Animation secondaryAnimation, Widget child, ) => FadeTransition( opacity: animation, // 透明度 child: child, // 页面存放 ), ); } 然后push方法直接更改为： push() { Navigator.push( context, FadeRoute(page: MyHomePage()), ); } 更多路由动画直接看： https://github.com/fluttercandies/nav_router/tree/master/lib/routers "},"chapter2/no_context_route.html":{"url":"chapter2/no_context_route.html","title":"2.3：干掉context进行路由管理","keywords":"","body":"干掉context进行路由管理 看下我们上节课留的报错： class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return new MaterialApp( title: 'Flutter高级进阶', home: new Scaffold( appBar: new AppBar(), body: new FlatButton(child: new Text(\"push\"), onPressed: () => push(context)), ), ); } /* * 路由跳转方法 * */ push(context) { //导航到新路由 Navigator.push( context, MaterialPageRoute( // MyHomePage不写参数则默认为1 builder: (context) => MyHomePage()), ); } } 报错信息： I/flutter (21935): ══╡ EXCEPTION CAUGHT BY GESTURE ╞═══════════════════════════════════════════════════════════════════ I/flutter (21935): The following assertion was thrown while handling a gesture: I/flutter (21935): Navigator operation requested with a context that does not include a Navigator. I/flutter (21935): The context used to push or pop routes from the Navigator must be that of a widget that is a I/flutter (21935): descendant of a Navigator widget. I/flutter (21935): I/flutter (21935): When the exception was thrown, this was the stack: I/flutter (21935): #0 Navigator.of. (package:flutter/src/widgets/navigator.dart:1475:9) I/flutter (21935): #1 Navigator.of (package:flutter/src/widgets/navigator.dart:1482:6) I/flutter (21935): #2 Navigator.push (package:flutter/src/widgets/navigator.dart:1107:22) I/flutter (21935): #3 MyApp.push (package:oc_project/main.dart:18:15) I/flutter (21935): #4 MyApp.build. (package:oc_project/main.dart:12:72) I/flutter (21935): #5 _InkResponseState._handleTap (package:flutter/src/material/ink_well.dart:654:14) I/flutter (21935): #6 _InkResponseState.build. (package:flutter/src/material/ink_well.dart:729:32) I/flutter (21935): #7 GestureRecognizer.invokeCallback (package:flutter/src/gestures/recognizer.dart:182:24) I/flutter (21935): #8 TapGestureRecognizer._checkUp (package:flutter/src/gestures/tap.dart:365:11) I/flutter (21935): #9 TapGestureRecognizer.handlePrimaryPointer (package:flutter/src/gestures/tap.dart:275:7) I/flutter (21935): #10 PrimaryPointerGestureRecognizer.handleEvent (package:flutter/src/gestures/recognizer.dart:455:9) I/flutter (21935): #11 PointerRouter._dispatch (package:flutter/src/gestures/pointer_router.dart:75:13) I/flutter (21935): #12 PointerRouter.route (package:flutter/src/gestures/pointer_router.dart:102:11) I/flutter (21935): #13 GestureBinding.handleEvent (package:flutter/src/gestures/binding.dart:218:19) I/flutter (21935): #14 GestureBinding.dispatchEvent (package:flutter/src/gestures/binding.dart:198:22) I/flutter (21935): #15 GestureBinding._handlePointerEvent (package:flutter/src/gestures/binding.dart:156:7) I/flutter (21935): #16 GestureBinding._flushPointerEventQueue (package:flutter/src/gestures/binding.dart:102:7) I/flutter (21935): #17 GestureBinding._handlePointerDataPacket (package:flutter/src/gestures/binding.dart:86:7) I/flutter (21935): #21 _invoke1 (dart:ui/hooks.dart:263:10) I/flutter (21935): #22 _dispatchPointerDataPacket (dart:ui/hooks.dart:172:5) I/flutter (21935): (elided 3 frames from package dart:async) I/flutter (21935): I/flutter (21935): Handler: \"onTap\" I/flutter (21935): Recognizer: I/flutter (21935): TapGestureRecognizer#72729 难道我们只能把home抽出成一个类来解决这个问题吗？实际上还有另一个方法，就是我们这节要讲的干掉那个上下文(context)， 来进行路由管理； 分析： 上节我提到NavigatorKey是一个管理路由的Key，咋们解决方案也是用这个NavigatorKey； 灵感来源： 我去查看Navigator源码的时候突然发现一个NavigatorState类，而且是具备Navigator的所有功能； 开始上手 首先定义一个NavigatorKey，也就是GlobalKey全局Key，然后范型是NavigatorState： final navGK = new GlobalKey(); 然后在MaterialApp设置这个Key为navigatorKey的值： class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return new MaterialApp( title: 'Flutter高级进阶', navigatorKey: navGK,// 设置navigatorKey home: new Scaffold( appBar: new AppBar(), body: new FlatButton(child: new Text(\"push\"), onPressed: () => push(), ), ), ); } } 然后使用这个Key来跳转即可： push() { //导航到新路由 navGK.currentState.push( MaterialPageRoute( // MyHomePage不写参数则默认为1 builder: (context) => MyHomePage()), ); } 效果图： 这样我们就完美干掉上下文进行路由管理了； "},"chapter2/my_route.html":{"url":"chapter2/my_route.html","title":"2.4：开发路由管理框架","keywords":"","body":"开发路由管理框架 看完之前两篇我们学会了： 路由入栈和路由出栈； 路由记录； 自定义路由动画； 路由传参和回退路由； 使用NavigatorKey进行路由管理； 那么我们今天就用之前的知识来自己开发一个属于自己的路由管理框架，这节所用到的知识就是路由封装方法， 这样使用起来只需传个新页面即可跳转了，或者随便传个自己想要的参数即可实现不一样的路由过度动画了； 开干 创建： flutter create --template=package nav_router nav_router为插件名字，我这边用我自己的。 路由过度动画枚举： enum RouterType { material, // 默认 cupertino, // cupertino风格 slide, // 滑动 scale, // 缩放 rotation, // 旋转 size, // 大小尺寸 fade, // 渐变 scaleRotate, // 缩放和旋转 } 定义NavigatorKey： final navGK = new GlobalKey(); 封装跳转方法： 目前演示Push方法，其他方法可查看本文最后的git项目地址或者查看Navigator自己慢慢补上； /// 接收一个页面 /// 路由动画类型如果没传则默认为cupertino风格 Future routePush(Widget page, [RouterType type = RouterType.cupertino]) { Route route = routerUtil(type: type, widget: page); // 使用navGK进行路由跳转 return navGK.currentState.push(route); } routerUtil： 用switch来判断应该使用哪个路由过度动画； Route routerUtil({RouterType type, widget}) { Route route; // 使用type来case switch (type) { // 如果type为RouterType.material case RouterType.material: // 执行materialRoute方法 route = materialRoute(widget); break;// 后面的以此类推 case RouterType.cupertino: route = cupertinoRoute(widget); break; case RouterType.slide: route = slide(widget); break; case RouterType.scale: route = scale(widget); break; case RouterType.rotation: route = rotation(widget); break; case RouterType.size: route = size(widget); break; case RouterType.fade: route = fade(widget); break; case RouterType.scaleRotate: route = scaleRotate(widget); break; } // 返回最终的route return route; } router： 那么我们case的需要执行的这些方法也是需要封装下； // cupertino风格路由动画 Route cupertinoRoute(widget) { return new CupertinoPageRoute( builder: (BuildContext context) => widget, settings: new RouteSettings( name: widget.toStringShort(), isInitialRoute: false, ), ); } // material风格路由动画 Route materialRoute(widget) { return new MaterialPageRoute( builder: (BuildContext context) => widget, settings: new RouteSettings( name: widget.toStringShort(), isInitialRoute: false, ), ); } // 滑动路由动画 Route slide(widget) { return SlideRightRoute(page: widget); } // 缩放路由动画 Route scale(widget) { return ScaleRoute(page: widget); } // 旋转路由动画 Route rotation(widget) { return RotationRoute(page: widget); } // 尺寸大小路由动画 Route size(widget) { return SizeRoute(page: widget); } // 渐变路由动画 Route fade(widget) { return FadeRoute(page: widget); } // 缩放加旋转路由动画 Route scaleRotate(widget) { return ScaleRotateRoute(page: widget); } 动画执行类： 这里因为太多了我暂时就放下渐变和缩放的； import 'package:flutter/material.dart'; // 缩放路由动画 class ScaleRoute extends PageRouteBuilder { // 接收的页面page final Widget page; // 构造 ScaleRoute({this.page}) : super( pageBuilder: ( BuildContext context, Animation animation, Animation secondaryAnimation, ) => page, transitionsBuilder: ( BuildContext context, Animation animation, Animation secondaryAnimation, Widget child, ) => ScaleTransition( scale: Tween( begin: 0.0, // 开始 end: 1.0, // 结束 ).animate( CurvedAnimation( parent: animation, curve: Curves.fastOutSlowIn, ), ), child: child, // 页面存放 ), ); } // 渐变路由动画 class FadeRoute extends PageRouteBuilder { // 接收的页面page final Widget page; // 构造 FadeRoute({this.page}) : super( pageBuilder: ( BuildContext context, Animation animation, Animation secondaryAnimation, ) => page, transitionsBuilder: ( BuildContext context, Animation animation, Animation secondaryAnimation, Widget child, ) => FadeTransition( opacity: animation, // 渐变的透明度 child: child,// 页面存放 ), ); } 更多路由动画直接看： https://github.com/fluttercandies/nav_router/tree/master/lib/routers 使用 引入 假设我是在插件的example目录使用，那么我就直接path方式引入； nav_router: path: ../ 导入 import 'package:nav_router/nav_router.dart'; 配置 因为我们使用的是navigatorKey形式跳转，所以必须在MaterialApp的navigatorKey配置好Key，否则无法使用； void main() => runApp(MyApp()); class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return new MaterialApp( title: 'NavRoute', navigatorKey: navGK, // 必须配置 home: new MyHomePage(), ); } } 路由跳转1： routePush(new NewPage()); 路由跳转2： routePush(new NewPage(), RouterType.fade); End 本文路由管理框架GitHub项目地址： https://github.com/fluttercandies/nav_router "},"chapter3/":{"url":"chapter3/","title":"第3章：原理篇","keywords":"","body":"本章目录 Flutter的setState更新原理和流程 runApp入口执行 "},"chapter3/setstate.html":{"url":"chapter3/setstate.html","title":"3.1：setState更新原理和流程","keywords":"","body":"分析 Flutter状态类： StatelessWidget：无状态类，没有状态更新，界面一经创建无法更改； StatefulWidget：有状态类，当状态改变，调用setState()方法会触发StatefulWidget的UI状态更新，自定义继承StatefulWidget的子类须重写createState()方法。 也就是只有当我们的类是有状态类的时候才能进行状态刷新，setState也是在State（有状态类）类里 解析 ： framework.dart文件State类 调用 setState() 必须是没有调用过 dispose() 方法，不然出错，可通过mounted属性来判断调用此方法是否合法。 if (mounted) { setState(() {}); } setState方法 void setState(VoidCallback fn) { ... _element.markNeedsBuild(); } setState方法除了一些条件判断就是：_element.markNeedsBuild(); 那我们看看markNeedsBuild。 Element 类 markNeedsBuild方法 void markNeedsBuild() { assert(_debugLifecycleState != _ElementLifecycle.defunct); // 由于一帧做两次更新有点低效，所以在如果`_active=false` 的时候直接返回。 if (!_active) return;//返回 ... if (dirty) return; // 设置`_dirty = true ` _dirty = true; //调用scheduleBuildFor方法 owner.scheduleBuildFor(this); } 将 element 元素标记为“脏”,并把它添加到全局的“脏”链表里,以便在下一帧更新信号时更新. 这里的“ 脏”链表是待更新的链表，更新过后就不“脏”了。 那我们看看本方法最后调用的scheduleBuildFor方法。 BuildOwner 类 scheduleBuildFor方法 BuildOwner类是widget framework的管理类，它跟踪那些需要重新构建的 widget。 void scheduleBuildFor(Element element) { ... if (element._inDirtyList) { ... _dirtyElementsNeedsResorting = true; return; } if (!_scheduledFlushDirtyElements && onBuildScheduled != null) { _scheduledFlushDirtyElements = true; onBuildScheduled();//回调 } _dirtyElements.add(element);//把element添加到脏元素链表 element._inDirtyList = true; assert(() { if (debugPrintScheduleBuildForStacks) debugPrint('...dirty list is now: $_dirtyElements'); return true; }()); } 把一个 element 添加到 _dirtyElements 链表，主要为了方便当WidgetsBinding.drawFrame中调用 buildScope 的时候能够重构 element。onBuildScheduled()是一个 BuildOwner 的回调。 onBuildScheduled回调在WidgetsBinding的initInstances里初始化。 mixin WidgetsBinding on BindingBase, SchedulerBinding, GestureBinding, RendererBinding, SemanticsBinding { @override void initInstances() { super.initInstances(); _instance = this; // 这里 buildOwner.onBuildScheduled = _handleBuildScheduled; // 赋值onBuildScheduled window.onLocaleChanged = handleLocaleChanged;window.onAccessibilityFeaturesChanged = handleAccessibilityFeaturesChanged; SystemChannels.navigation.setMethodCallHandler(_handleNavigationInvocation); SystemChannels.system.setMessageHandler(_handleSystemMessage); FlutterErrorDetails.propertiesTransformers.add(transformDebugCreator); } } 可以看到Flutter应用启动过程初始化WidgetsBinding时buildOwner.onBuildScheduled回调等于了 _handleBuildScheduled，那现在来看看这个_handleBuildScheduled方法： void _handleBuildScheduled() { //调用ensureVisualUpdate ensureVisualUpdate(); } 可以看到调用ensureVisualUpdate方法，那我们继续走下去。 SchedulerBinding类ensureVisualUpdate方法 void ensureVisualUpdate() { switch (schedulerPhase) { case SchedulerPhase.idle: case SchedulerPhase.postFrameCallbacks: //当schedulerPhase为SchedulerPhase.idle， //SchedulerPhase.postFrameCallbacks时调用scheduleFrame() scheduleFrame(); return; case SchedulerPhase.transientCallbacks: case SchedulerPhase.midFrameMicrotasks: case SchedulerPhase.persistentCallbacks: return; } } schedulerPhase的初始值为SchedulerPhase.idle。SchedulerPhase是一个enum枚举类型， 分别case了SchedulerPhase 的 5 个枚举值： 状态 含义 idle 没有正在处理的帧，可能正在执行的是 WidgetsBinding.scheduleTask，scheduleMicrotask，Timer，事件 handlers，或者其他回调等 transientCallbacks SchedulerBinding.handleBeginFrame 过程， 处理动画状态更新 midFrameMicrotasks 处理 transientCallbacks 阶段触发的微任务（Microtasks） persistentCallbacks WidgetsBinding.drawFrame 和 SchedulerBinding.handleDrawFrame 过程，build/layout/paint 流水线工作 postFrameCallbacks 主要是清理和计划执行下一帧的工作 第二个case调用scheduleFrame()方法 那我们看看scheduler/binding.dart文件的SchedulerBinding类scheduleFrame()方法 void scheduleFrame() { // 这个判断表示只有当APP处于可见状态才会准备调度下一帧方法 if (_hasScheduledFrame || !_framesEnabled) return; assert(() { if (debugPrintScheduleFrameStacks) debugPrintStack( label: 'scheduleFrame() called. Current phase is $schedulerPhase.'); return true; }()); //调用Window 的scheduleFrame方法是一个 native 方法 window.scheduleFrame(); _hasScheduledFrame = true; } 这里的 window.scheduleFrame()方法是一个Native方法， 由于本人并没有扎实的原生经验所以下方借鉴了袁辉辉大佬的部分讲解， lib/ui/window.dart文件 Window类 (Native) void scheduleFrame() native 'Window_scheduleFrame'; window是Flutter引擎中跟图形相关接口打交道的核心类。 ScheduleFrame(C++) window.cc文件 void ScheduleFrame(Dart_NativeArguments args) { // 看下方 RuntimeController::ScheduleFrame UIDartState::Current()->window()->client()->ScheduleFrame(); } 通过RegisterNatives()完成native方法的注册，“Window_scheduleFrame”所对应的native方法如上所示。 RuntimeController::ScheduleFrame 所在文件：flutter/runtime/runtime_controller.cc void RuntimeController::ScheduleFrame() { client_.ScheduleFrame(); // 看下面Engine::ScheduleFrame } Engine::ScheduleFrame 所在文件：flutter/shell/common/engine.cc void Engine::ScheduleFrame(bool regenerate_layer_tree) { animator_->RequestFrame(regenerate_layer_tree); } 这里推荐查看袁辉辉大佬的：Flutter渲染机制—UI线程 文中小节[2.1]介绍Engine::ScheduleFrame()经过层层调用，最终会注册Vsync回调。 等待下一次vsync信号的到来， 然后再经过层层调用最终会调用到Window::BeginFrame()。 Window::BeginFrame 所在文件：flutter/lib/ui/window/window.cc void Window::BeginFrame(fml::TimePoint frameTime) { std::shared_ptr dart_state = library_.dart_state().lock(); if (!dart_state) return; tonic::DartState::Scope scope(dart_state); int64_t microseconds = (frameTime - fml::TimePoint()).ToMicroseconds(); DartInvokeField(library_.value(), \"_beginFrame\", { Dart_NewInteger(microseconds), }); //执行MicroTask UIDartState::Current()->FlushMicrotasksNow(); DartInvokeField(library_.value(), \"_drawFrame\", {}); } Window::BeginFrame()过程主要工作： 执行_beginFrame 执行FlushMicrotasksNow 执行_drawFrame 可见，Microtask位于beginFrame和drawFrame之间，那么Microtask的耗时会影响ui绘制过程。 handleBeginFrame 文件所在: lib/src/scheduler/binding.dart SchedulerBinding类 void handleBeginFrame(Duration rawTimeStamp) { Timeline.startSync('Frame', arguments: timelineWhitelistArguments); _firstRawTimeStampInEpoch ??= rawTimeStamp; _currentFrameTimeStamp = _adjustForEpoch(rawTimeStamp ?? _lastRawTimeStamp); if (rawTimeStamp != null) _lastRawTimeStamp = rawTimeStamp; profile(() { _profileFrameNumber += 1; _profileFrameStopwatch.reset(); _profileFrameStopwatch.start(); }); //此时阶段等于SchedulerPhase.idle; _hasScheduledFrame = false; try { Timeline.startSync('Animate', arguments: timelineWhitelistArguments); _schedulerPhase = SchedulerPhase.transientCallbacks; //执行动画的回调方法 final Map callbacks = _transientCallbacks; _transientCallbacks = {}; callbacks.forEach((int id, _FrameCallbackEntry callbackEntry) { if (!_removedIds.contains(id)) _invokeFrameCallback(callbackEntry.callback, _currentFrameTimeStamp, callbackEntry.debugStack); }); _removedIds.clear(); } finally { _schedulerPhase = SchedulerPhase.midFrameMicrotasks; } } 该方法主要功能是遍历_transientCallbacks，执行相应的Animate操作， 可通过scheduleFrameCallback()/cancelFrameCallbackWithId()来完成添加和删除成员， 再来简单看看这两个方法。 handleDrawFrame 文件所在：lib/src/scheduler/binding.dart SchedulerBinding类 void handleDrawFrame() { assert(_schedulerPhase == SchedulerPhase.midFrameMicrotasks); Timeline.finishSync(); // 标识结束\"Animate\"阶段 try { _schedulerPhase = SchedulerPhase.persistentCallbacks; //执行PERSISTENT FRAME回调 for (FrameCallback callback in _persistentCallbacks) _invokeFrameCallback(callback, _currentFrameTimeStamp); _schedulerPhase = SchedulerPhase.postFrameCallbacks; // 执行POST-FRAME回调 final List localPostFrameCallbacks = List.from(_postFrameCallbacks); _postFrameCallbacks.clear(); for (FrameCallback callback in localPostFrameCallbacks) _invokeFrameCallback(callback, _currentFrameTimeStamp); } finally { _schedulerPhase = SchedulerPhase.idle; Timeline.finishSync(); //标识结束”Frame“阶段 profile(() { _profileFrameStopwatch.stop(); _profileFramePostEvent(); }); _currentFrameTimeStamp = null; } } 该方法主要功能： 遍历_persistentCallbacks，执行相应的回调方法，可通过addPersistentFrameCallback()注册，一旦注册后不可移除，后续每一次frame回调都会执行； 遍历_postFrameCallbacks，执行相应的回调方法，可通过addPostFrameCallback()注册，handleDrawFrame()执行完成后会清空_postFrameCallbacks内容。 UI 的绘制逻辑【附加】 UI 的绘制逻辑是在 Render 树中实现的，所以这里还来细看 RendererBinding 的逻辑。 RendererBinding 【附加】 void initInstances() { ... //监听Window对象的事件 ui.window ..onMetricsChanged = handleMetricsChanged ..onTextScaleFactorChanged = handleTextScaleFactorChanged ..onSemanticsEnabledChanged = _handleSemanticsEnabledChanged ..onSemanticsAction = _handleSemanticsAction; //添加PersistentFrameCallback addPersistentFrameCallback(_handlePersistentFrameCallback); } addPersistentFrameCallback 中添加 _handlePersistentFrameCallback 最终调用了 drawFrame 而 WidgetsBinding 重写了 RendererBinding 中的 drawFrame() 方法。最终发现我们又回到了 WidgetsBinding 这个类中，在 WidgetsBinding 中 drawFrame 的实现如下： @override void drawFrame() { ... try { if (renderViewElement != null) // 重构需要更新的element buildOwner.buildScope(renderViewElement); super.drawFrame(); //调用RendererBinding的drawFrame()方法 buildOwner.finalizeTree(); } } 在上面 scheduleBuildFor 方法介绍中有提到：\"scheduleBuildFor 是把一个 element 添加到 _dirtyElements 链表，以便当[WidgetsBinding.drawFrame]中调用 buildScope 的时候能够重构 element。onBuildScheduled()是一个 BuildOwner 的回调\"。在 drawFrame 中调用 buildOwner.buildScope(renderViewElement)更新 elements。 void buildScope(Element context, [ VoidCallback callback ]) { ... while (index 得出 条件判断 1.生命周期判断 2.是否可以进行刷新：mounted 添加脏链表 _dirty = true 1.“脏”链表是待更新的链表 2.更新过后就不“脏”了 3._active=false 的时候直接返回 管理类 1.告诉管理类方法自己需要被重新构建： owner.scheduleBuildFor(this) 调用 window.scheduleFrame() =》native 方法 RegisterNatives()完成native方法的注册 最终会注册Vsync回调。 等待下一次vsync信号的到来， 然后再经过层层调用最终会调用到 Window::BeginFrame() UI 的绘制逻辑是在 Render 树中实现的 更新帧信号来临从而刷新需要重构的界面 在 drawFrame 中调用 buildOwner.buildScope(renderViewElement)更新 elements "},"chapter3/run_app.html":{"url":"chapter3/run_app.html","title":"3.2：runApp入口执行","keywords":"","body":"runApp 我们平常的App入口都是： void main() => runApp(MyApp()); 那runApp到底做了什么，怎么来执行这个MyApp的？ void runApp(Widget app) { WidgetsFlutterBinding.ensureInitialized() //确保初始化 ..attachRootWidget(app) //附加根小部件 ..scheduleWarmUpFrame(); //安排热身帧 } runApp方法接收一个Widget类型app值，这个值是我们需要显示的界面Widget， 然后我们看到第一个是调用了WidgetsFlutterBinding.ensureInitialized()， // WidgetsFlutterBinding('flutter/lib/src/widgets/binding.dart') class WidgetsFlutterBinding extends BindingBase with GestureBinding, ServicesBinding, SchedulerBinding, PaintingBinding, SemanticsBinding, RendererBinding, WidgetsBinding { static WidgetsBinding ensureInitialized() { if (WidgetsBinding.instance == null) WidgetsFlutterBinding(); return WidgetsBinding.instance; } } 这WidgetsFlutterBinding是一个单例类，WidgetsFlutterBinding继承了BindingBase并且with了大量的mixin, 官方给的注释： 基于Widgets框架的应用程序的具体绑定。 这是将框架绑定到Flutter引擎的粘合剂。 也就是说这个类是将Widget架构和Flutter底层Engine连接的桥梁。 那么 ensureInitialized() 就是负责初始化以及返回实例的。 Widget到Element到RenderObject的流程 初始化后就会继续调用attachRootWidget(app)： // WidgetsBinding (flutter/lib/src/widgets/binding.dart) // 取得一个小部件并将其附加到[renderViewElement] // 该方法完成了Widget到Element到RenderObject的整个关联过程 void attachRootWidget(Widget rootWidget) { _renderViewElement = RenderObjectToWidgetAdapter( container: renderView, debugShortDescription: '[root]', child: rootWidget, ).attachToRenderTree(buildOwner, renderViewElement); // 看下个方法讲解 } 就是将传入的Widget包装到RenderObjectToWidgetAdapter，它继承自RenderObjectWidget， 负责将Widget、Element、RenderObject三者关联起来，其中的RenderObject对应前面初始化操作中创建的renderView。 其中renderView和_renderViewElement为WidgetsFlutterBinding的成员， 可以看出每个app只存在一个renderViewElement和renderView，并且一一对应。 attachToRenderTree // RenderObjectToWidgetAdapter（flutter/lib/src/widgets/binding.dart） // 此方法负责创建根Element，也就是RenderObjectToWidgetElement /// 官方注释： ///给这个小部件充气，然后将结果[RenderObject]设置为 /// [container]的子级。 ///如果`element`为null，则此函数将创建一个新元素。 除此以外， ///给定的元素将安排更新以切换到此小部件。 ///可以看出Element只会创建一次，后面会进行复用 /// /// [runApp]用于引导应用程序。 RenderObjectToWidgetElement attachToRenderTree (BuildOwner owner, [ RenderObjectToWidgetElement element ]) { // 如果`element`为null if (element == null) { // 创建根Element，RenderObjectToWidgetElement owner.lockState(() { element = createElement(); assert(element != null); element.assignOwner(owner); }); owner.buildScope(element, () { // 这里会根据WidgetTree构建ElementTree element.mount(null, null); // 看下面的mount方法讲解 }); } else { // 则此函数将创建一个新元素 element._newWidget = this; element.markNeedsBuild(); // markNeedsBuild在setState更新原理和流程有讲到 } return element; } mount // RenderObjectToWidgetAdapter（flutter/lib/src/widgets/binding.dart） @override void mount(Element parent, dynamic newSlot) { assert(parent == null); // 断言接收的parent等于空 super.mount(parent, newSlot); _rebuild(); } _rebuild // RenderObjectToWidgetAdapter（flutter/lib/src/widgets/binding.dart） void _rebuild() { try { // 实际上是调用updateChild更新ElementTree _child = updateChild(_child, widget.child, _rootChildSlot); // 查看【updateChild】 assert(_child != null); } catch (exception, stack) { // 红屏产生的地方 final FlutterErrorDetails details = FlutterErrorDetails( exception: exception, stack: stack, library: 'widgets library', context: ErrorDescription('attaching to the render tree'), ); // 这里打印了错误栈 FlutterError.reportError(details); // 这里就是创建了红屏的Widget，显示在屏幕上 // 自定义ErrorWidget看下一个方法 final Widget error = ErrorWidget.builder(details); _child = updateChild(null, error, _rootChildSlot);// 查看【updateChild】 } } 自定义ErrorWidget报错页面 void main() async { runApp(MyApp()); /// 自定义报错页面 ErrorWidget.builder = (FlutterErrorDetails flutterErrorDetails) { debugPrint(flutterErrorDetails.toString()); return new Center(child: new Text(\"App错误，快去反馈给作者!\")); }; } updateChild() 更新ElementTree 实际上该方法只执行了updateChild()，该方法至关重要，ElementTree的生成主要就在方法中实现， 我们来细看一下代码，注意代码中添加的注释： // child表示要更新的Element，newWidget表示对应Element的Widget， // newSlot用来标识Element的所在位置，返回该位置对应的新Element @protected Element updateChild(Element child, Widget newWidget, dynamic newSlot) { assert(() { // Debug下保证一个GlobalKey只对应一个Widget if (newWidget != null && newWidget.key is GlobalKey) { final GlobalKey key = newWidget.key; key._debugReserveFor(this); } return true; }()); if (newWidget == null) { // 如果newWidget为空，child非空表示需要移除旧Element if (child != null) deactivateChild(child); // 将此Element的位置设为null return null; } if (child != null) { // 都不为空且是相同Widget，更新位置标识即可 if (child.widget == newWidget) { if (child.slot != newSlot) updateSlotForChild(child, newSlot); // 更新后返回原Element return child; } // 若不是相同Widget则判断是否有相同的类型和相同的Key，是的话则更新Widget信息到Element if (Widget.canUpdate(child.widget, newWidget)) { if (child.slot != newSlot) updateSlotForChild(child, newSlot); child.update(newWidget); assert(child.widget == newWidget); assert(() { child.owner._debugElementWasRebuilt(child); return true; }()); // 更新后返回原Element return child; } // 若不符合更新的要求，则抛弃掉原Element，抛弃掉的Element会被回收到`_inactiveElements`列表中，不会立即被销毁 deactivateChild(child); assert(child._parent == null); } // 其他情况下需要创建新的Element return inflateWidget(newWidget, newSlot); //查看【inflateWidget】 } 总结 newWidget等于空 newWidget不等于空 child等于空 返回null. 返回新 [Element]. child不等于空 旧child被删除，返回空. 可能会更新旧的子级，返回子级或新的[Element]. inflateWidget ///为给定的小部件创建一个元素，并将其添加为该元素的子元素给定插槽中的元素。 /// ///此方法通常由[updateChild]调用，但可以调用直接由需要更精细地控制创建的子类元素。 /// ///如果给定的小部件具有全局键并且已经存在一个元素有一个带有该全局键的小部件，此函数将重用该元素 ///（可能从树中的其他位置移植或重新激活从无效元素列表中获取），而不是创建一个新元素。 /// ///此函数返回的元素将已经被挂载并将处于“活动”生命周期状态。 @protected Element inflateWidget(Widget newWidget, dynamic newSlot) { assert(newWidget != null); final Key key = newWidget.key; if (key is GlobalKey) { // 先使用key去被回收的列表中看看是否有可以复用的Element final Element newChild = _retakeInactiveElement(key, newWidget); if (newChild != null) { assert(newChild._parent == null); assert(() { _debugCheckForCycles(newChild); return true; }()); newChild._activateWithParent(this, newSlot); // 找到后就复用被回收的Element，并且更新它的Child final Element updatedChild = updateChild(newChild, newWidget, newSlot); assert(newChild == updatedChild); return updatedChild; } } // 没有可以复用的Element了，创建新的 final Element newChild = newWidget.createElement(); assert(() { _debugCheckForCycles(newChild); return true; }()); // mount安装新的Element newChild.mount(this, newSlot); assert(newChild._debugLifecycleState == _ElementLifecycle.active); // 返回新的child return newChild; } 新创建的Element继续调用mount，于是又会触发新一轮的updateChild， 最终对应WidgetTree的整个ElementTree就构建完成了。 渲染回调等部分 渲染主要是在WidgetsFlutterBinding类开始执行的，runApp方法最后也是执行了WidgetsFlutterBinding类的 scheduleWarmUpFrame方法进行第一次绘制。 ///锁定事件调度，直到调度的框架完成为止。 ///也就是这次完成之后才会开始绘制其他scheduledFrame。 ///如果已经使用[scheduleFrame]安排了帧，或者[scheduleForcedFrame]，此调用可能会延迟该帧。 ///如果任何预定的帧已经开始或其他[scheduleWarmUpFrame]已被调用，此调用将被忽略。 ///首选[scheduleFrame]在正常操作下更新显示。 void scheduleWarmUpFrame() { if (_warmUpFrame || schedulerPhase != SchedulerPhase.idle) return; _warmUpFrame = true; Timeline.startSync('Warm-up frame'); final bool hadScheduledFrame = _hasScheduledFrame; // 我们在这里使用计时器来确保微任务在两者之间刷新。 Timer.run(() { assert(_warmUpFrame); handleBeginFrame(null); // 【主要方法1】 }); Timer.run(() { assert(_warmUpFrame); handleDrawFrame(); // 【主要方法2】 //我们在此帧之后调用resetEpoch resetEpoch(); _warmUpFrame = false; if (hadScheduledFrame) scheduleFrame(); }); //锁定事件，以便触摸事件等直到预定的帧已完成。 lockEvents(() async { await endOfFrame; Timeline.finishSync(); }); } 其实绘制主要是用到了handleBeginFrame()和handleDrawFrame()两个方法， 因为这两个方法调用由scheduleFrameCallback命令注册的所有需要的回调。 所以建议看这两个方法之前了解下Frame和FrameCallbacks： Frame Frame即每一帧的绘制过程，engine通过VSync信号不断地触发Frame的绘制， 实际上就是调用SchedulerBinding类中的_handleBeginFrame()和_handleDrawFrame()这两个方法， 这个过程中会完成动画、布局、绘制等工作。 FrameCallbacks Frame绘制期间，有三个callbacks列表会被调用，这三个列表是SchedulerBinding类中的成员，它们的调用顺序如下： 顺序 内容 transientCallbacks 由Ticker触发和停止，一般用于动画的回调 persistentCallbacks 永久callback，添加后无法移除，由WidgetsBinding.instance.addPersitentFrameCallback()注册，这个回调处理了布局与绘制工作 postFrameCallbacks 只调一次，调用后会被系统移除，可由WidgetsBinding.instance.addPostFrameCallback()注册，该回调一般用于State的更新 handleBeginFrame方法 代码已忽略断言部分。 // SchedulerBinding(flutter/lib/src/scheduler/binding.dart) /// 如果给定的时间戳为null，则最后一帧的时间戳为重用。 void handleBeginFrame(Duration rawTimeStamp) { Timeline.startSync('Frame', arguments: timelineWhitelistArguments); _firstRawTimeStampInEpoch ??= rawTimeStamp; _currentFrameTimeStamp = _adjustForEpoch(rawTimeStamp ?? _lastRawTimeStamp); if (rawTimeStamp != null) _lastRawTimeStamp = rawTimeStamp; _hasScheduledFrame = false; try { // transientCallbacks回调 Timeline.startSync('Animate', arguments: timelineWhitelistArguments); _schedulerPhase = SchedulerPhase.transientCallbacks; final Map callbacks = _transientCallbacks; _transientCallbacks = {}; callbacks.forEach((int id, _FrameCallbackEntry callbackEntry) { if (!_removedIds.contains(id)) _invokeFrameCallback(callbackEntry.callback, _currentFrameTimeStamp, callbackEntry.debugStack); }); _removedIds.clear(); } finally { _schedulerPhase = SchedulerPhase.midFrameMicrotasks; } } 这里主要执行了transientCallbacks回调。 handleDrawFrame 执行了persistentCallbacks和postFrameCallbacks回调，主要的操作都在这里。 /// handleBeginFrame之后立即调用此方法。 触发全部addPersistentFrameCallback注册的回调，通常 ///驱动渲染管道，然后调用addPostFrameCallback。 void handleDrawFrame() { assert(_schedulerPhase == SchedulerPhase.midFrameMicrotasks); Timeline.finishSync(); // 结束“动画”阶段 try { // persistentCallbacks回调 _schedulerPhase = SchedulerPhase.persistentCallbacks; for (FrameCallback callback in _persistentCallbacks) _invokeFrameCallback(callback, _currentFrameTimeStamp); // postFrameCallbacks回调 _schedulerPhase = SchedulerPhase.postFrameCallbacks; final List localPostFrameCallbacks = List.from(_postFrameCallbacks); _postFrameCallbacks.clear(); for (FrameCallback callback in localPostFrameCallbacks) _invokeFrameCallback(callback, _currentFrameTimeStamp); } finally { _schedulerPhase = SchedulerPhase.idle; Timeline.finishSync(); //结束帧 assert(() { if (debugPrintEndFrameBanner) debugPrint('▀' * _debugBanner.length); _debugBanner = null; return true; }()); _currentFrameTimeStamp = null; } } 渲染操作 系统只在persistentCallbacks注册了一个回调， 实际上是执行RenderBinding类中的drawFrame()方法以及其子类WidgetsBinding类中的drawFrame()方法： @protected void drawFrame() { pipelineOwner.flushLayout(); // 看 【3.2.1】 pipelineOwner.flushCompositingBits(); // 看 【3.2.2】 pipelineOwner.flushPaint(); // 看 【3.2.3】 renderView.compositeFrame(); // 看 【3.2.4】 pipelineOwner.flushSemantics(); // 看 【3.2.5】 } WidgetsBinding /// 代码忽略了断言和判断 @override void drawFrame() { try { if (renderViewElement != null) buildOwner.buildScope(renderViewElement); super.drawFrame(); buildOwner.finalizeTree(); } finally { ... } _needToReportFirstFrame = false; } buildOwner.buildScope()在我们的\"setState更新原理和流程\"有讲到过，可以直接搜索。 该方法会将被标记为dirty的Element进行重新构建。 回收被抛弃的Element的列表_inactiveElements最后会调用buildOwner.finalizeTree()彻底清除掉。 3.2.1 pipelineOwner.flushLayout() 该方法更新所有脏渲染对象的布局等信息。 /// 布局信息在绘制之前已清理，因此渲染对象将出现在屏幕上的最新位置。 /// /// 当RenderObject的宽高等布局相关的属性被set时（通过更改Widget的属性）， /// 它会被添加到_nodesNeedingLayout列表中，以标记为需要重新进行layout。 /// 这里遍历了该列表，并调用_layoutWithoutResize()进行布局 void flushLayout() { ... try { while (_nodesNeedingLayout.isNotEmpty) { final List dirtyNodes = _nodesNeedingLayout; _nodesNeedingLayout = []; for (RenderObject node in dirtyNodes ..sort((RenderObject a, RenderObject b) => a.depth - b.depth)) { if (node._needsLayout && node.owner == this) node._layoutWithoutResize(); } } } finally { ... } } 3.2.2 flushCompositingBits 在flushLayout之后和之前作为渲染管道的一部分调用 /// 用于判断RenderObject是否拥有自己的layer，如果该状态变化了，就会将该RenderObject标记为需要进行重绘的， /// 然后在下面flushPaint()方法中进行重绘。 void flushCompositingBits() { ... _nodesNeedingCompositingBitsUpdate .sort((RenderObject a, RenderObject b) => a.depth - b.depth); for (RenderObject node in _nodesNeedingCompositingBitsUpdate) { if (node._needsCompositingBitsUpdate && node.owner == this) node._updateCompositingBits(); } _nodesNeedingCompositingBitsUpdate.clear(); ... } 3.2.3 flushPaint /// 该方法就是进行绘制的地方，可以看出它不是重绘了所有RenderObject，而是只重绘了被标记为dirty的RenderObject， /// 这些RenderObject会调用engine下的skia库进行绘制。 void flushPaint() { final List dirtyNodes = _nodesNeedingPaint; _nodesNeedingPaint = []; // 以相反的顺序对脏节点进行排序（最深的优先）。 for (RenderObject node in dirtyNodes ..sort((RenderObject a, RenderObject b) => b.depth - a.depth)) { assert(node._layer != null); if (node._needsPaint && node.owner == this) { if (node._layer.attached) { PaintingContext.repaintCompositedChild(node); } else { node._skippedPaintingOnLayer(); } } } ... } 3.2.4 compositeFrame // RenderView(flutter/lib/src/rendering/view.dart) ///将合成的层树上载到引擎。 ///实际上使渲染管道的输出出现在屏幕上。 void compositeFrame() { Timeline.startSync('Compositing', arguments: timelineWhitelistArguments); try { final ui.SceneBuilder builder = ui.SceneBuilder(); final ui.Scene scene = layer.buildScene(builder); if (automaticSystemUiAdjustment) _updateSystemChrome(); _window.render(scene); scene.dispose(); } finally { Timeline.finishSync(); } ... } 将画好的layer传给engine，该方法调用结束之后，手机屏幕就会显示出内容了。 3.2.5 flushSemantics /// Semantics用于将一些Widget的信息传给系统用于搜索、App内容分析等场景，这与Flutter绘制流程关系不大。 void flushSemantics() { final List nodesToProcess = _nodesNeedingSemantics.toList() ..sort((RenderObject a, RenderObject b) => a.depth - b.depth); _nodesNeedingSemantics.clear(); for (RenderObject node in nodesToProcess) { if (node._needsSemanticsUpdate && node.owner == this) node._updateSemantics(); } _semanticsOwner.sendSemanticsUpdate(); } 总结 其实就是根据传入的Widget生成对应的ElementTree和RenderTree，之后开始进行首帧的布局和绘制。 其中Widget用来描述页面的属性，这个对象是十分轻量级的且是不可变的，同一个Widget可以描述多个Element的配置， Element同时持有了Widget和RenderObject，它汇总了所有的属性信息，重绘时只将需要修改的部分通知到RenderObject。 对于普通开发者，只需要关注最上层的Widget就可以了，十分简单高效。 由于本人能力有限，部分讲解借鉴了超丶赛亚叼的，在此致敬。 "},"chapter4/":{"url":"chapter4/","title":"第4章：状态篇","keywords":"","body":"本章目录 Bloc-Stream入门 Bloc-状态管理 "},"chapter4/steam.html":{"url":"chapter4/steam.html","title":"4.1：Bloc-Stream入门","keywords":"","body":"Bloc-Stream入门 作者正在偷懒。。。 "},"chapter4/bloc.html":{"url":"chapter4/bloc.html","title":"4.2：Bloc-状态管理","keywords":"","body":"Bloc-状态管理 作者正在偷懒。。。 "},"chapter5/":{"url":"chapter5/","title":"第5章：架构篇","keywords":"","body":"本章目录 MVVM架构搭建 MVC架构搭建 "},"chapter5/mvvm.html":{"url":"chapter5/mvvm.html","title":"5.1：MVVM架构搭建","keywords":"","body":"MVVM架构搭建 文章暂未存放，稍等一会。 "},"chapter5/mvc.html":{"url":"chapter5/mvc.html","title":"5.2：MVC架构搭建","keywords":"","body":"MVC架构搭建 文章暂未存放，稍等一会。 "}}