{"./":{"url":"./","title":"简介","keywords":"","body":"作者 q1，一年Flutter工作经验，Flutter教程网 创办者，微信公众号\"Flutter前线\"小编， FlutterCandies开源组织成员，具有： wechat_flutter， nav_router等开源项目作品， 视频课程：Flutter实用例子进阶课程 ， 高仿谷歌翻译项目课程， 目前就职于广州某创业公司， 持续对Flutter社区输出文章资源，主要关注移动端行业发展和技术更新迭代，不断进步。 简介 本书主要讲解Flutter进阶，深入原理，以及工作所可能遇到的技术栈和问题解决方案、面试中 可能遇到的问题，以实战角度进行：文案、思维导图、代码示例、工作原理、使用方式进行讲解， 可帮助开发者快速进阶flutter技术。 章节介绍 本书分为多个章节，不确定性，会一直更，直到完善，然后固定章节，目前已有章节： 进阶篇、原理篇、Flutter面试题。 本书暂未想过发版实体书，主要发布电子版供大家学习参考。 持续更新中。。。敬请期待！ "},"chapter1/":{"url":"chapter1/","title":"第一章：进阶篇","keywords":"","body":"本章目录 Flutter的生命周期 局部刷新优化性能 屏幕适配之组件应用 屏幕适配之屏幕算法 根据控件位置弹出对话框 "},"chapter1/life_cycle.html":{"url":"chapter1/life_cycle.html","title":"1.1：生命周期","keywords":"","body":"生命周期 Flutter生命周期相对于android的Activity，ta存在于framework.dart的State类， 实测 写个有状态类并混入WidgetsBindingObserver配合监听特殊状态及其一个按钮，调用setState， 给生命周期的方法新增打印： import 'package:flutter/material.dart'; void main() => runApp(new MyApp()); class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return new MaterialApp( title: '生命周期', home: new LiftCycle(), ); } } class LiftCycle extends StatefulWidget { @override _LiftCycleState createState() => _LiftCycleState(); } class _LiftCycleState extends State with WidgetsBindingObserver { int count = 0; @override void initState() { super.initState(); WidgetsBinding.instance.addObserver(this); print('初始化 initState'); } @override void didUpdateWidget(LiftCycle oldWidget) { super.didUpdateWidget(oldWidget); print('组件更新 didUpdateWidget'); } @override void reassemble() { super.reassemble(); print('重新安装 reassemble'); } @override void deactivate() { super.deactivate(); print('停用 deactivate'); } @override void dispose() { super.dispose(); WidgetsBinding.instance.removeObserver(this); print('销毁 dispose'); } @override void didChangeAppLifecycleState(AppLifecycleState state) { super.didChangeAppLifecycleState(state); print('特殊状态 state：$state'); } @override void setState(fn) { super.setState(fn); print('状态刷新 setState'); } @override Widget build(BuildContext context) { return new Scaffold( appBar: new AppBar(title: new Text('生命周期')), body: new Center( child: new FlatButton( onPressed: () => setState(() => count++), child: new Text('$count'), ), ), ); } @override void didChangeDependencies() { super.didChangeDependencies(); print('依赖改变 didChangeDependencies'); } } 然后我们现在来看看打印流程，正常打开App什么都不操作，就打印了： I/flutter (15867): 初始化 initState I/flutter (15867): 依赖改变 didChangeDependencies I/flutter (15867): 重新安装 reassemble I/flutter (15867): 组件更新 didUpdateWidget 热重载打印： I/flutter (16141): 重新安装 reassemble I/flutter (16141): 组件更新 didUpdateWidget Reloaded 0 of 468 libraries in 186ms. 点击按钮打印： I/flutter (16141): 状态刷新 setState // count也+1了，说明重新调用过build。 流程图 图解主要部分： 1.构建（build）； 2.如果用户调用了setState时则状态刷新，重新build； 3.如果销毁先停用然后dispose销毁再结束； 构造函数 构造函数不属于生命周期，必然是要第一个调用的，也就是调用前State的widget属性为空。 initState 初始化 当此对象插入树中时调用，框架会调用一次此方法并不会再次重复执行， 如果[State]的[build]方法依赖于本身可以更改状态的对象，例如[ChangeNotifier]或[Stream]， 或者某些其他可以订阅的对象接收通知，可以在此方法订阅，但记得去dispose取消订阅； didChangeDependencies 依赖改变 故名思意，依赖项更改时调用，但也会在initState之后调用， 在这个方法调用[BuildContext.inheritFromWidgetOfExactType]是安全的。 build 构建 会在以下场景调用： initState()之后； didUpdateWidget()之后； setState()之后。 didChangeDependencies()之后。 State对象从树中一个位置移除后会调用deactivate，然后又重新插入到树的其它位置之后。 reassemble 重新安装 专门为了开发调试而提供的，在热重载(hot reload)时会被调用，此回调在Release模式下永远不会被调用。 didUpdateWidget 组件更新 当组件的状态改变的时候就会调用didUpdateWidget(),比如调用了setState()， 在widget重新构建时，Flutter framework会调用Widget.canUpdate来检测Widget树中同一位置的新旧节点， 然后决定是否需要更新，如果Widget.canUpdate返回true则会调用此回调。正如之前所述，Widget.canUpdate会在 新旧widget的key和runtimeType同时相等时会返回true，也就是说在新旧widget的key和runtimeType同时相等时didUpdateWidget()就会被调用。 deactivate 暂停 State对象从树中被移除时（在dispose之前），会调用这个函数来将对象暂停。 dispose 销毁 当State对象被销毁时调用，通常在此回调中释放资源和移除监听。 【 特殊状态 】 我们自定义的State类混入了WidgetsBindingObserver，所以可以使用他的暂停和恢复， 初始化： @override void initState() { super.initState(); WidgetsBinding.instance.addObserver(this); // 在这初始化了 print('初始化 initState'); } 销毁： @override void dispose() { super.dispose(); WidgetsBinding.instance.removeObserver(this); // 在这销毁 print('销毁 dispose'); } 使用： @override void didChangeAppLifecycleState(AppLifecycleState state) { super.didChangeAppLifecycleState(state); print('特殊状态 state：$state'); } 这个didChangeAppLifecycleState是WidgetsBindingObserver类的一个方法， 可以用来判断当前的状态是在前台还是后台。 这个方法接收一个AppLifecycleState类型的枚举： 枚举值 含义 resumed 程序可见，并响应用户输入。 inactive 处于非活动状态，未收到用户输入。 paused 程序当前不可见，不响应用户输入，并且在后台运行。 suspending 程序将暂时暂停。 AppLifecycleState实测 当App返回到桌面或者其他不可见状态，但并未结束： I/flutter ( 2428): 特殊状态 state：AppLifecycleState.inactive I/flutter ( 2428): 特殊状态 state：AppLifecycleState.paused 当App回到可见状态： I/flutter ( 2428): 特殊状态 state：AppLifecycleState.inactive I/flutter ( 2428): 特殊状态 state：AppLifecycleState.resumed 流程图： "},"chapter1/partial_refresh.html":{"url":"chapter1/partial_refresh.html","title":"1.2：局部刷新优化性能","keywords":"","body":"局部刷新优化性能 Flutter状态类： StatelessWidget：无状态类，没有状态更新，界面一经创建无法更改； StatefulWidget：有状态类，当状态改变，调用setState()方法会触发StatefulWidget的UI状态更新，自定义继承StatefulWidget的子类须重写createState()方法。 案例： 当我们调用有状态类的setState方法时会遍历每一个子Widget的State.build刷新状态， 这将是一笔很大的性能开销，所以我们需要使用局部刷新来进行优化。 普通刷新方式 class TestRoute extends StatefulWidget { @override _TestRouteState createState() => _TestRouteState(); } class _TestRouteState extends State { int count = 0; @override Widget build(BuildContext context) { return new FlatButton( onPressed: () { setState(() => count++); }, child: new Text('$count'), ); } } 一个有状态类定义一个变量然后按钮的事件调用setState让这个变量进行刷新， 使用GlobalKey局部刷新方式 我们还是用上面的例子，只是通过GlobalKey的方式只刷新局部的Text， class TestRoute extends StatefulWidget { @override _TestRouteState createState() => _TestRouteState(); } class _TestRouteState extends State { int count = 0; GlobalKey textKey = GlobalKey(); @override Widget build(BuildContext context) { return new Column( mainAxisAlignment: MainAxisAlignment.center, children: [ new TextWidget(textKey), //需要更新的Text new FlatButton( onPressed: () { count++; // 这里我们只给他值变动，状态刷新交给下面的Key事件 textKey.currentState.onPressed(count); }, child: new Text('按钮 $count'), ), ], ); } } // 封装的文本组件Widget class TextWidget extends StatefulWidget { final Key key; // 接收一个Key TextWidget(this.key); @override State createState() => TextWidgetState(); } class TextWidgetState extends State { String _text = \"0\"; @override Widget build(BuildContext context) { return new Text(_text); } void onPressed(int count) { setState(() => _text = count.toString()); } } 效果： 可以明显的看到按钮的count并无变动，但需要更新的文本组件更新了值，已经完美实现了局部刷新。 实现原理： textKey是一个GlobalKey类型的Key范型为TextWidgetState（封装的文本&&有状态类）， 所以这个Key可以通过currentState方法调用到类里面的onPressed方法， 而onPressed方法刚好有调用setState来刷新局部状态。 "},"chapter1/screen_widget.html":{"url":"chapter1/screen_widget.html","title":"1.3：屏幕适配之组件应用","keywords":"","body":"分析 Flutter可用适配组件： Expanded、Flexible、Spacer、AspectRatio、Wrap、GridView、Table、SafeArea.... 案例1 分析： 一行，两边外边距为10，两个区块宽高相等，右边区块一个列也是宽高相等， 右边的下区块又是一行，两边相等，所有间隔都为10。 代码： new Container( // 容器组件 height: 200, // 设置默认高度 margin: EdgeInsets.symmetric(horizontal: 10.0),// 两边的外边距 child: new Row( // 一行显示 children: [ // 第一个区块 new Expanded( child: new Container( decoration: BoxDecoration( borderRadius: BorderRadius.all(Radius.circular(4.0)),// 圆角 color: Colors.amber.withOpacity(0.5)),// 颜色 ), ), // 间隔 new SizedBox(width: 10.0, height: 10.0), // 第二个区块 new Expanded( child: new Column( children: [ new Expanded( // 继续用Expanded撑开 child: new Container( decoration: BoxDecoration( borderRadius: BorderRadius.all(Radius.circular(4.0)),// 圆角 color: Colors.grey.withOpacity(0.5),// 颜色 ), ), ), new SizedBox(width: 10.0, height: 10.0),// 间隔10 new Expanded( child: new Row( children: [ new Expanded( child: new Container( decoration: BoxDecoration( borderRadius: BorderRadius.all( Radius.circular(4.0), ), color: Colors.red.withOpacity(0.5), ), ), ), new SizedBox(width: 10.0, height: 10.0), new Expanded( child: new Container( decoration: BoxDecoration( borderRadius: BorderRadius.all( Radius.circular(4.0), ), color: Colors.blueAccent.withOpacity(0.5)), ), ), ], ), ) ], ), ), // 为了使代码简单就不减少嵌套了 ], ), ) 这样就实现了Expanded自适应屏幕了，Expanded有个flex属性， 是负责控制占比空间的，不写则默认为1，值越大则占比越大。 Expanded 示例代码： new Container( height: 100, // 设置默认高度 margin: EdgeInsets.symmetric(horizontal: 10.0), child: new Row( children: [ // 第一个区块 new Expanded( flex: 1, child: new Container( decoration: BoxDecoration( borderRadius: BorderRadius.all(Radius.circular(4.0)), color: Colors.amber.withOpacity(0.5)), ), ), // 间隔 new SizedBox(width: 10.0, height: 10.0), // 第而个区块 new Expanded( flex: 2, child: new Container( decoration: BoxDecoration( borderRadius: BorderRadius.all( Radius.circular(4.0), ), color: Colors.blueAccent.withOpacity(0.5), ), ), ), // 为了使代码简单就不减少嵌套了 ], ), ); 第一个区块占比为1，第二个为2，则效果为： Spacer Spacer同Expanded一样具有flex属性，其含义和使用也是一模一样， 一般用于Row（行）或 Column（列）组件。 示例代码： new Column( children: [ new Container( height: 200, decoration: BoxDecoration( borderRadius: BorderRadius.all(Radius.circular(4.0)), color: Colors.amber.withOpacity(0.5), ), ), new Spacer(flex: 1), new Container( height: 200, decoration: BoxDecoration( borderRadius: BorderRadius.all(Radius.circular(4.0)), color: Colors.blueAccent.withOpacity(0.5), ), ), ], ) 效果： 我们给最下面那个区块也加个Spacer试试： new Column( children: [ ... new Container( ... ), new Spacer(flex: 1), ], ) 效果： 如果flex设置为2则会为第一个的两倍间隔。 "},"chapter1/screen_algorithm.html":{"url":"chapter1/screen_algorithm.html","title":"1.4：屏幕适配之屏幕算法","keywords":"","body":"屏幕适配之屏幕算法 既然是算法适配就必然少不了获取屏幕宽高，我们用的就是媒体查询（MediaQuery）， 下面是封装方法过后的，当然直接使用也是可以的： // 整屏宽度 double winWidth(BuildContext context) { return MediaQuery.of(context).size.width; } // 整屏高度 double winHeight(BuildContext context) { return MediaQuery.of(context).size.height; } 案例1： 蓝湖设计图有一张轮播图，宽度是 335 高度是 120，左右间隔是10， 如何使用屏幕算法适配全机型屏幕宽和高？ 分析： 左右间隔：设置margin然后左右10个间隔； 宽度：整宽减20，20就是左右的间隔； 高度：(宽度) * 120 / 335； 代码： new Container( height: (winWidth(context) - 20) * 120 / 335, width: winWidth(context) - 20, margin: EdgeInsets.symmetric(horizontal: 10.0), alignment: Alignment.center, decoration: BoxDecoration( borderRadius: BorderRadius.all(Radius.circular(4.0)), color: Colors.amber.withOpacity(0.5), ), child: new Text('模拟图片'), ), 效果 这就是一个普通的屏幕算法适配例子，他会一直按照这个比例，兼容所有机型。 案例2： 蓝湖设计图：未知数据数量有规则的列表视图，要求一行显示5个， 每个间隔为10（含上下），最外边距margin左右都为20，高度为50， 多出的数据继续往下排并向左对齐，适配任何机型。 分析： 左右间隔：设置margin然后左右20个间隔； 间隔和高：除最外边左右，内边都为10间隔，并包含上下，高度固定50； 对齐方式：对齐方式默认都为向左对齐； 组件：推荐Wrap，动态数据，依次撑开； 代码： class MyHomePage extends StatelessWidget { @override Widget build(BuildContext context) { return new Scaffold( appBar: new AppBar( title: new Text('Flutter高级进阶'), ), body: new Container( padding: EdgeInsets.symmetric(vertical: 20.0),// 为了保持美观给了上下价格20 color: Colors.amber.withOpacity(0.2), // 为了验证动态撑开给了背景 child: TestRoute(),// 主代码 ), ); } } class TestRoute extends StatefulWidget { @override _TestRouteState createState() => _TestRouteState(); } class _TestRouteState extends State { Widget buildItem(item) { return new Container( decoration: BoxDecoration( borderRadius: BorderRadius.all(Radius.circular(4.0)), // 圆角 color: Colors.blueAccent.withOpacity(0.5),// item颜色 ), height: 50.0, // 高度 alignment: Alignment.center, // item文本剧中 width: (winWidth(context) - 80) / 5, // 宽度 child: new Text('模拟'), ); } @override Widget build(BuildContext context) { return new Container( width: winWidth(context) - 40, // 宽度容器算法 margin: EdgeInsets.symmetric(horizontal: 20.0), child: new Wrap( spacing: 10.0, runSpacing: 10.0, children: [0, 1, 2, 3, 4, 5].map(buildItem).toList(), ), ); } } 效果 "},"chapter2/":{"url":"chapter2/","title":"第二章：原理篇","keywords":"","body":"本章目录 Flutter的setState更新原理和流程 "},"chapter2/setstate.html":{"url":"chapter2/setstate.html","title":"1.1：setState更新原理和流程","keywords":"","body":"分析 Flutter状态类： StatelessWidget：无状态类，没有状态更新，界面一经创建无法更改； StatefulWidget：有状态类，当状态改变，调用setState()方法会触发StatefulWidget的UI状态更新，自定义继承StatefulWidget的子类须重写createState()方法。 也就是只有当我们的类是有状态类的时候才能进行状态刷新，setState也是在State（有状态类）类里 解析 ： framework.dart文件State类 调用 setState() 必须是没有调用过 dispose() 方法，不然出错，可通过mounted属性来判断调用此方法是否合法。 if (mounted) { setState(() {}); } setState方法 void setState(VoidCallback fn) { ... _element.markNeedsBuild(); } setState方法除了一些条件判断就是：_element.markNeedsBuild(); 那我们看看markNeedsBuild。 Element 类 markNeedsBuild方法 void markNeedsBuild() { assert(_debugLifecycleState != _ElementLifecycle.defunct); // 由于一帧做两次更新有点低效，所以在如果`_active=false` 的时候直接返回。 if (!_active) return;//返回 ... if (dirty) return; // 设置`_dirty = true ` _dirty = true; //调用scheduleBuildFor方法 owner.scheduleBuildFor(this); } 将 element 元素标记为“脏”,并把它添加到全局的“脏”链表里,以便在下一帧更新信号时更新. 这里的“ 脏”链表是待更新的链表，更新过后就不“脏”了。 那我们看看本方法最后调用的scheduleBuildFor方法。 BuildOwner 类 scheduleBuildFor方法 BuildOwner类是widget framework的管理类，它跟踪那些需要重新构建的 widget。 void scheduleBuildFor(Element element) { ... if (element._inDirtyList) { ... _dirtyElementsNeedsResorting = true; return; } if (!_scheduledFlushDirtyElements && onBuildScheduled != null) { _scheduledFlushDirtyElements = true; onBuildScheduled();//回调 } _dirtyElements.add(element);//把element添加到脏元素链表 element._inDirtyList = true; assert(() { if (debugPrintScheduleBuildForStacks) debugPrint('...dirty list is now: $_dirtyElements'); return true; }()); } 把一个 element 添加到 _dirtyElements 链表，主要为了方便当WidgetsBinding.drawFrame中调用 buildScope 的时候能够重构 element。onBuildScheduled()是一个 BuildOwner 的回调。 onBuildScheduled回调在WidgetsBinding的initInstances里初始化。 mixin WidgetsBinding on BindingBase, SchedulerBinding, GestureBinding, RendererBinding, SemanticsBinding { @override void initInstances() { super.initInstances(); _instance = this; // 这里 buildOwner.onBuildScheduled = _handleBuildScheduled; // 赋值onBuildScheduled window.onLocaleChanged = handleLocaleChanged;window.onAccessibilityFeaturesChanged = handleAccessibilityFeaturesChanged; SystemChannels.navigation.setMethodCallHandler(_handleNavigationInvocation); SystemChannels.system.setMessageHandler(_handleSystemMessage); FlutterErrorDetails.propertiesTransformers.add(transformDebugCreator); } } 可以看到Flutter应用启动过程初始化WidgetsBinding时buildOwner.onBuildScheduled回调等于了 _handleBuildScheduled，那现在来看看这个_handleBuildScheduled方法： void _handleBuildScheduled() { //调用ensureVisualUpdate ensureVisualUpdate(); } 可以看到调用ensureVisualUpdate方法，那我们继续走下去。 SchedulerBinding类ensureVisualUpdate方法 void ensureVisualUpdate() { switch (schedulerPhase) { case SchedulerPhase.idle: case SchedulerPhase.postFrameCallbacks: //当schedulerPhase为SchedulerPhase.idle， //SchedulerPhase.postFrameCallbacks时调用scheduleFrame() scheduleFrame(); return; case SchedulerPhase.transientCallbacks: case SchedulerPhase.midFrameMicrotasks: case SchedulerPhase.persistentCallbacks: return; } } schedulerPhase的初始值为SchedulerPhase.idle。SchedulerPhase是一个enum枚举类型， 分别case了SchedulerPhase 的 5 个枚举值： 状态 含义 idle 没有正在处理的帧，可能正在执行的是 WidgetsBinding.scheduleTask，scheduleMicrotask，Timer，事件 handlers，或者其他回调等 transientCallbacks SchedulerBinding.handleBeginFrame 过程， 处理动画状态更新 midFrameMicrotasks 处理 transientCallbacks 阶段触发的微任务（Microtasks） persistentCallbacks WidgetsBinding.drawFrame 和 SchedulerBinding.handleDrawFrame 过程，build/layout/paint 流水线工作 postFrameCallbacks 主要是清理和计划执行下一帧的工作 第二个case调用scheduleFrame()方法 那我们看看scheduler/binding.dart文件的SchedulerBinding类scheduleFrame()方法 void scheduleFrame() { // 这个判断表示只有当APP处于可见状态才会准备调度下一帧方法 if (_hasScheduledFrame || !_framesEnabled) return; assert(() { if (debugPrintScheduleFrameStacks) debugPrintStack( label: 'scheduleFrame() called. Current phase is $schedulerPhase.'); return true; }()); //调用Window 的scheduleFrame方法是一个 native 方法 window.scheduleFrame(); _hasScheduledFrame = true; } 这里的 window.scheduleFrame()方法是一个Native方法， 由于本人并没有扎实的原生经验所以下方借鉴了袁辉辉大佬的部分讲解， lib/ui/window.dart文件 Window类 (Native) void scheduleFrame() native 'Window_scheduleFrame'; window是Flutter引擎中跟图形相关接口打交道的核心类。 ScheduleFrame(C++) window.cc文件 void ScheduleFrame(Dart_NativeArguments args) { // 看下方 RuntimeController::ScheduleFrame UIDartState::Current()->window()->client()->ScheduleFrame(); } 通过RegisterNatives()完成native方法的注册，“Window_scheduleFrame”所对应的native方法如上所示。 RuntimeController::ScheduleFrame 所在文件：flutter/runtime/runtime_controller.cc void RuntimeController::ScheduleFrame() { client_.ScheduleFrame(); // 看下面Engine::ScheduleFrame } Engine::ScheduleFrame 所在文件：flutter/shell/common/engine.cc void Engine::ScheduleFrame(bool regenerate_layer_tree) { animator_->RequestFrame(regenerate_layer_tree); } 这里推荐查看袁辉辉大佬的：Flutter渲染机制—UI线程 文中小节[2.1]介绍Engine::ScheduleFrame()经过层层调用，最终会注册Vsync回调。 等待下一次vsync信号的到来， 然后再经过层层调用最终会调用到Window::BeginFrame()。 Window::BeginFrame 所在文件：flutter/lib/ui/window/window.cc void Window::BeginFrame(fml::TimePoint frameTime) { std::shared_ptr dart_state = library_.dart_state().lock(); if (!dart_state) return; tonic::DartState::Scope scope(dart_state); int64_t microseconds = (frameTime - fml::TimePoint()).ToMicroseconds(); DartInvokeField(library_.value(), \"_beginFrame\", { Dart_NewInteger(microseconds), }); //执行MicroTask UIDartState::Current()->FlushMicrotasksNow(); DartInvokeField(library_.value(), \"_drawFrame\", {}); } Window::BeginFrame()过程主要工作： 执行_beginFrame 执行FlushMicrotasksNow 执行_drawFrame 可见，Microtask位于beginFrame和drawFrame之间，那么Microtask的耗时会影响ui绘制过程。 handleBeginFrame 文件所在: lib/src/scheduler/binding.dart SchedulerBinding类 void handleBeginFrame(Duration rawTimeStamp) { Timeline.startSync('Frame', arguments: timelineWhitelistArguments); _firstRawTimeStampInEpoch ??= rawTimeStamp; _currentFrameTimeStamp = _adjustForEpoch(rawTimeStamp ?? _lastRawTimeStamp); if (rawTimeStamp != null) _lastRawTimeStamp = rawTimeStamp; profile(() { _profileFrameNumber += 1; _profileFrameStopwatch.reset(); _profileFrameStopwatch.start(); }); //此时阶段等于SchedulerPhase.idle; _hasScheduledFrame = false; try { Timeline.startSync('Animate', arguments: timelineWhitelistArguments); _schedulerPhase = SchedulerPhase.transientCallbacks; //执行动画的回调方法 final Map callbacks = _transientCallbacks; _transientCallbacks = {}; callbacks.forEach((int id, _FrameCallbackEntry callbackEntry) { if (!_removedIds.contains(id)) _invokeFrameCallback(callbackEntry.callback, _currentFrameTimeStamp, callbackEntry.debugStack); }); _removedIds.clear(); } finally { _schedulerPhase = SchedulerPhase.midFrameMicrotasks; } } 该方法主要功能是遍历_transientCallbacks，执行相应的Animate操作， 可通过scheduleFrameCallback()/cancelFrameCallbackWithId()来完成添加和删除成员， 再来简单看看这两个方法。 handleDrawFrame 文件所在：lib/src/scheduler/binding.dart SchedulerBinding类 void handleDrawFrame() { assert(_schedulerPhase == SchedulerPhase.midFrameMicrotasks); Timeline.finishSync(); // 标识结束\"Animate\"阶段 try { _schedulerPhase = SchedulerPhase.persistentCallbacks; //执行PERSISTENT FRAME回调 for (FrameCallback callback in _persistentCallbacks) _invokeFrameCallback(callback, _currentFrameTimeStamp); _schedulerPhase = SchedulerPhase.postFrameCallbacks; // 执行POST-FRAME回调 final List localPostFrameCallbacks = List.from(_postFrameCallbacks); _postFrameCallbacks.clear(); for (FrameCallback callback in localPostFrameCallbacks) _invokeFrameCallback(callback, _currentFrameTimeStamp); } finally { _schedulerPhase = SchedulerPhase.idle; Timeline.finishSync(); //标识结束”Frame“阶段 profile(() { _profileFrameStopwatch.stop(); _profileFramePostEvent(); }); _currentFrameTimeStamp = null; } } 该方法主要功能： 遍历_persistentCallbacks，执行相应的回调方法，可通过addPersistentFrameCallback()注册，一旦注册后不可移除，后续每一次frame回调都会执行； 遍历_postFrameCallbacks，执行相应的回调方法，可通过addPostFrameCallback()注册，handleDrawFrame()执行完成后会清空_postFrameCallbacks内容。 UI 的绘制逻辑【附加】 UI 的绘制逻辑是在 Render 树中实现的，所以这里还来细看 RendererBinding 的逻辑。 RendererBinding 【附加】 void initInstances() { ... //监听Window对象的事件 ui.window ..onMetricsChanged = handleMetricsChanged ..onTextScaleFactorChanged = handleTextScaleFactorChanged ..onSemanticsEnabledChanged = _handleSemanticsEnabledChanged ..onSemanticsAction = _handleSemanticsAction; //添加PersistentFrameCallback addPersistentFrameCallback(_handlePersistentFrameCallback); } addPersistentFrameCallback 中添加 _handlePersistentFrameCallback 最终调用了 drawFrame 而 WidgetsBinding 重写了 RendererBinding 中的 drawFrame() 方法。最终发现我们又回到了 WidgetsBinding 这个类中，在 WidgetsBinding 中 drawFrame 的实现如下： @override void drawFrame() { ... try { if (renderViewElement != null) // 重构需要更新的element buildOwner.buildScope(renderViewElement); super.drawFrame(); //调用RendererBinding的drawFrame()方法 buildOwner.finalizeTree(); } } 在上面 scheduleBuildFor 方法介绍中有提到：\"scheduleBuildFor 是把一个 element 添加到 _dirtyElements 链表，以便当[WidgetsBinding.drawFrame]中调用 buildScope 的时候能够重构 element。onBuildScheduled()是一个 BuildOwner 的回调\"。在 drawFrame 中调用 buildOwner.buildScope(renderViewElement)更新 elements。 void buildScope(Element context, [ VoidCallback callback ]) { ... while (index 得出 条件判断 1.生命周期判断 2.是否可以进行刷新：mounted 添加脏链表 _dirty = true 1.“脏”链表是待更新的链表 2.更新过后就不“脏”了 3._active=false 的时候直接返回 管理类 1.告诉管理类方法自己需要被重新构建： owner.scheduleBuildFor(this) 调用 window.scheduleFrame() =》native 方法 RegisterNatives()完成native方法的注册 最终会注册Vsync回调。 等待下一次vsync信号的到来， 然后再经过层层调用最终会调用到 Window::BeginFrame() UI 的绘制逻辑是在 Render 树中实现的 更新帧信号来临从而刷新需要重构的界面 在 drawFrame 中调用 buildOwner.buildScope(renderViewElement)更新 elements "},"chapter1/widget_offset.html":{"url":"chapter1/widget_offset.html","title":"1.5：根据控件位置弹出对话框","keywords":"","body":"根据控件位置弹出对话框 内容更新中。。。 "}}